#summary to be continued...

=Mocks presentation=

*specs* offers a lightweight framework to create mocks and stubs (see [http://www.mockobjects.com/ this] reference and [http://martinfowler.com/articles/mocksArentStubs.html that one] for a discussion on mocks and stubs).

Using mocks follows a 4 steps process:

  # extend the `Mocker` trait 
{{{
  object mySpec extends Specification with scala.specs.mock.Mocker {...}
}}}
  # override the methods in the class or trait you want to mock and implement them with the `record` method
{{{
  class MockedService extends Service {
    override def executeService = record
  }
}}}
  # add expectations in your specification example
{{{
  object mySpec extends Specification with Mocker {
    "my system" should {
      "use mocks" in {
         val mock = new MockedService
         expect {
           mock.executeService
         }
         ...
      }
    }
  }
}}}
  # use the mock in the rest of your example, expectations will be automatically checked at the end of the example

===A complete example===

Here is a complete example of the use of mocks to specify the interactions between a `Button` and a `Light`:
{{{
trait ButtonAndLightMock extends ButtonAndLight with Mocker {
  val mock = new Light { 
    override def on = record
    override def off = record
  }
  val button = Button(mock)
}
trait ButtonAndLight {
  case class Button(light: Light) {
    var lightOn = false
    def push = {
      if (lightOn) light.off else light.on 
      lightOn = !lightOn
    }
  }
  case class Light {
    var state: LightState = Off
    def on = state = On
    def off = state = Off
    def isOn = state == On
  }
  abstract sealed class LightState(s: String)
  case class On extends LightState("on")
  case class Off extends LightState("off")
}

object mockExample extends Specification with ButtonAndLightMock {
  "A button and light mock example" should {
    "not fail if the mock receives the expected messages" in {
      expect {mock.on; mock.off}
      button.push
      button.push  // if the button is pressed twice, then the light will go on and off
    }
  }
}
}}}

=Mock protocols=

By default, the mock expectations order is not important and any excess message will be ignored. This default decision is motivated by the need to make the specification more robust in case of a minor implementation changes (such as the order of calls).

However you can specify that the calls must happen in sequence:
{{{
  expect(inSequence) { mock.on; mock.off }
}}}

You can also specify that unexpected calls must be reported as failures:
{{{
  expect(exclusively) { mock.on; mock.off }
}}}

===Repeated calls===

You may want to be even more precise when specifying mock expectations by using the following `ProtocolTypes`:

 * anyOf: any of the expected calls
{{{
 expect(anyOf) {mock.on; mock.off}
}}

 * oneOf: the expected calls must be received 1 time only
{{{
 expect(oneOf) {mock.on; mock.off}
 // will fail if `3.times {i => button.push}`
}}

You use a protocol type by passing it as a parameter to the `expect` function:
{{{
  expect(twoOf) { mock.on; mock.off }
}}}