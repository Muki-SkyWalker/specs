#summary how to use jMock in your specs

= Introduction =

[http://www.jmock.org/ jMock2] allows to define mocks and expectations on mocks very easily.

This page shows how to use jMock with specs. Please refer to the jMock site for more instructions on jMock itself. You can also have a look at the [http://specs.googlecode.com/svn/trunk/src/test/scala/org/specs/mock/jmockSpec.scala spec for the jMock integration] for more examples.

= Libraries =

In order to use jMock2 with specs, you need to add the following dependencies to your project: 
[http://repo1.maven.org/maven2/org/jmock/jmock/2.4.0 jmock-2.4.0.jar],  
[http://repo1.maven.org/maven2/org/hamcrest/hamcrest-all/1.1 hamcrest-1.1.jar]
and
[http://repo1.maven.org/maven2/cglib/cglib/2.1_3 cglib-2.1_3.jar], 
[http://repo1.maven.org/maven2/asm/asm/1.3.5 asm-1.5.3.jar], 
[http://repo1.maven.org/maven2/org/objenesis/objenesis/1.1 objenesis-1.1.jar] if you want to mock classes. 

Here is a sample maven snippet you can add to your pom.xml file:
{{{
    <dependency>
      <groupId>org.jmock</groupId>
      <artifactId>jmock</artifactId>
      <version>2.4.0</version>
    </dependency>
    <!-- Those are only needed if you want to mock classes -->
    <dependency>
      <groupId>cglib</groupId>
      <artifactId>cglib</artifactId>
      <version>2.1_3</version>
    </dependency>
    <dependency>
      <groupId>org.objenesis</groupId>
      <artifactId>objenesis</artifactId>
      <version>1.0</version>
    </dependency>
}}}

*You also need to add the flags -Ygenerics and -target:jvm-1.5 when compiling (until Scala 2.7.0)*

= A simple mock example with specs and jMock =

Using mocks follows a 4 steps process:

   1. extend the JMocker trait and add !ClassMocker if you want to mock classes as well as interfaces:
{{{
import scala.specs.mock._
object mySpec extends Specification with JMocker with ClassMocker {...}
}}}
*It is especially important that JMocker is mixed-in with your Specification, otherwise the expectations won't be checked*

   2. create mock objects using the `mock` method
{{{
object mySpec extends Specification with JMocker with ClassMocker {
  "my system" should {
    "use mocks" in {
      val mockedService = mock(classOf[Service])
    }
  }
}
}}}

   3. add expectations in your specification example
{{{
object mySpec extends Specification with JMocker with ClassMocker {
  "my system" should {
    "use mocks" in {
      val mockedService = mock(classOf[Service])
      expect {
        one(mockedService).executeService() // this will be called one time exactly
      }
      ...
    }
  }
}
}}}
   4. use the mock in the rest of your example, expectations will be automatically checked at the end of the example 
{{{
object mySpec extends Specification with JMocker with ClassMocker {
  "my system" should {
    "use mocks" in {
      val mockedService = mock(classOf[Service])
      expect {
        one(mockedService).executeService() // this will be called one time exactly
      }
      val whatIWantToTest = new WhatIWantToTest(mockedService)
      whatIWantToTest.executeMethod // must call once mockedService.executeService or the example will fail
    }
  }
}
}}}

=A complete example=

Here is a complete example of the use of mocks to specify the interactions between a `Button` and a `Light` object:
{{{
trait ButtonAndLightMock extends ButtonAndLight with JMocker with ClassMocker {
  val mock = mock(classOf[Light])
  val button = Button(mock)
}
trait ButtonAndLight {
  case class Button(light: Light) {
    var lightOn = false
    def push = {
      if (lightOn) light.off else light.on 
      lightOn = !lightOn
    }
  }
  case class Light {
    var state: LightState = Off
    def on = state = On
    def off = state = Off
    def isOn = state == On
  }
  abstract sealed class LightState(s: String)
  case class On extends LightState("on")
  case class Off extends LightState("off")
}

object mockExample extends Specification with ButtonAndLightMock {
  "A button and light mock example" should {
    "not fail if the mock receives the expected messages" in {
      expect {
        one(mock).on
        one(mock).off
      }
      button.push
      button.push  // if the button is pressed twice, then the light will go on and off
    }
  }
}
}}}

= Methods expectations =

==Methods counters==
All the standard jMock method expectations are available with specs. However, a little bit of syntactic sugar has been added:
{{{
  expect {
    exactly(2).of(mock).on // is equivalent to 
    2.of(mock).on

    atLeast(2).of(mock).on // is equivalent to 
    2.atLeastOf(mock).on

    (2 to 4).of(mock).on // between 2 and 4 calls to list.size
  }
}}}

==Allowing or ignoring methods==

Some shortcuts are available to allow or ignore some method calls:
{{{
  expect {
    allowingMatch("on") // allow any method matching "on"
    allowingMatch(mock, "on") // allow any method matching "on" on the object "mock"
    ignoringMatch("on") // ignore any method matching "on"
    ignoringMatch(mock, "on") // ignore any method matching "on" on the object "mock"
  }
}}}

==Returned values==

Scala allows a chain method call expectations with the specification of the returned values with `will`, `willReturn` and `willReturnIterable`:
{{{
expect { 
  one(List("hey")).take(anyInt) will returnValue(equal(List("hey"))) // `will` accepts a jMock action, like returnValue
  one(List("hey")).take(anyInt) willReturn List("hey") // `willReturn` specifies a returned value
  one(List("hey")).take(anyInt) willReturnIterable("a", "b") // `willReturnIterable` returns an Iterable with specified values
}
}}}

==Returned values on consecutive calls==

specs offers the `willReturnEach` method to specify that consecutive calls to a given method will return different values:
{{{
  // returns "a" the first time the "get" method is called, "b" the second time and "c" the third time
  1.atLeastOf(list).get(anyInt) willReturnEach ("a", "b", "c") 
}}}

==Nested returned values and mocks==

There is a frequent situation when interacting with object graphs. You need to mock an object, like a Connection, which is supposed to give you access to a service, that you also want to mock and so on. For example, testing some code accessing the Eclipse platform can be very difficult for that reason. 

Using specs you can use blocks to specify nested expectations:
{{{
  // A workspace gives access to a project and a project to a module
  case class Module(name: String)
  case class Project(module: Module, name: String)
  case class Workspace(project: Project)
  val workspace = mock(classOf[Workspace])
  
  expect { 
    one(workspace).project.willReturn(classOf[Project]) {p: Project => 
        // nested expectations on project
        one(p).name willReturn "hi"
        one(p).module.willReturn(classOf[Module]) {m: Module => 
          // nested expectation on module
          one(m).name willReturn "module"}
    }
  }

}}}

or

{{{
  // a workspace is a list of projects
  case class Project(name: String)
  case class Workspace(projects: List[Project])
  val workspace = mock(classOf[Workspace]) 
  expect { 
    // the workspace will return project mocks with different expectations
    one(workspace).projects willReturnIterable(classOf[Project], 
           {p: Project => one(p).name willReturn "p1" },
           {p: Project => one(p).name willReturn "p2" })
  }

}}}

==Thrown exceptions==

You can declare that a method call will throw an exception with `willThrow`:
{{{
expect { 
  one(list).get(will(beEqual(0))) willThrow new java.lang.Exception("ouch") 
}
}}}

==Method parameters==

Shortcuts are provided for the most common types of parameters:
{{{
  anyInt, anyLong, anyShort, anyByte, anyDouble, anyFloat, anyChar, anyString
  any(<anything>)
  a(classOf[Type])
  aNull(classOf[Type])
  aNonNull(classOf[Type])
  equal(value)
  same(value)
}}}

==Matchers adaptation==

A lot of jMock methods are expecting Hamcrest matchers:
{{{
  expect { 
    one(list).get(`with`(same(0))) // same(0) == new IsSame(0). Note the `backticks` on "with" which is a Scala reserved keyword
  }
}}}

Thanks to an implicit conversion from specs matchers to Hamcrest matchers, you can use specs matchers instead, using the `will` method:
{{{
  expect { 
    one(list).get(will(beEqual(0))) // beEqual(0) is a specs matchers
  }
}}}

*Note*: the be_== matcher can't be used here as it is expecting a value of type Any. This is why you should use beEqual[T](a: T).

==Sequence expectations==

You can constrain calls to occur in sequence, with the `then` method:
{{{
expect { 
  one(list).size then 
  one(list).get(anyInt) then
  one(list).isEmpty
}
}}}

==State expectations==

You can model expectations on some abstracts states, using the `when` and `set` methods
{{{
  val readiness = state("readiness")
  readiness.startsAs("not ready")
  expect { 
    one(list).size set readiness.is("ready") 
    allowing(list).get(anyInt) when readiness.is("ready")
  }
}}}