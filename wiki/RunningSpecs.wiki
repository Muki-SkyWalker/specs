#summary How to execute specifications

 * [http://code.google.com/p/specs/wiki/RunningSpecs#Run_your_specification_in_the_Console Run your specification in the Console]
 * [http://code.google.com/p/specs/wiki/RunningSpecs#Run_your_specification_with_JUnit4 Run your specification with JUnit4]
 * [http://code.google.com/p/specs/wiki/RunningSpecs#Run_your_specifications_with_JUnit4_and_Maven Run your specifications with JUnit4 and Maven]
 * [http://code.google.com/p/specs/wiki/RunningSpecs#Run_your_specification_with_JUnit4_in_Eclipse Run your specification with JUnit4 in Eclipse]
 * [http://code.google.com/p/specs/wiki/RunningSpecs#Run_your_specification_with_JUnit4_and_Ant Run your specification with JUnit4 and Ant]
 * [http://code.google.com/p/specs/wiki/RunningSpecs#Run_your_specification_with_ScalaTest Run your specification with ScalaTest]
 * [http://code.google.com/p/specs/wiki/RunningSpecs#Declare_several_spec_runners_at_once Declare several spec runners at once]
 * [http://code.google.com/p/specs/wiki/RunningSpecs#Run_your_specifications_and_get_the_results_as_an_XML_file Run your specifications and get the results as an XML file]
 * [http://code.google.com/p/specs/wiki/RunningSpecs#Skip_examples Skip examples]
 * [http://code.google.com/p/specs/wiki/RunningSpecs#Include_or_exclude_examples Include or exclude examples]

=Run your specification in the Console=

You can run your specifications in the console just by invoking scala on the Specification class:
{{{
package org.hw
import org.specs._

object helloWorld extends Specification { ... }
}}}

`java -cp ... org.hw.helloWorld`

If you have several exceptions being thrown and if stacktraces are obscuring the Console output you can turn them off by passing the `-ns` or `--nostacktrace` option.

===Find specifications in a directory path===

You can use the `SpecsFinder` class to find specifications in a given path:
{{{
object displaySpecifications extends SpecsFinder with Application {
  // print all specifications contained in subdirectories of the project directory
  // whose names are matching "all.*"
  specificationNames("project/**/*.scala", "all.*") foreach { println(_) }
}
}}}

To be more specific, the name of the specification will be retrieved if the scala file contains:
{{{
\\s*object\\s*(" + pattern + ")\\s*extends\\s*.*Spec.*\\s*\\{"
}}}

===Execute specifications in a directory path===

You simply use the `SpecsFileRunner`, with the parameters required for the `SpecsFinder`:
{{{
import org.specs.runner.SpecsFileRunner

object allSpecsRunner extends SpecsFileRunner("project/**/*.scala", "all.*")
}}}
 
The `SpecsFileRunner` will find possible specification names with the `SpecsFinder` and will try to instantiate them, keeping them only if the resulting object is an instance of `Specification`.

===How to redirect the results on a different output===

If you want to redirect the result of the execution to a file for example, you have to create a new trait extending the `Output` trait:
{{{
trait FileOutput extends Output {
  def println(m: Any) = {...}
  def printf(format: String, args: Any*) = {...}
  def flush() = {...}
}
}}}

And then you "mix" it with the `ConsoleRunner`:
{{{
object mySpecRunner extends ConsoleRunner(mySpec) with FileOutput
object mySpec extends Specification { ... }
}}}

On the command line, you can then invoke: `java -cp ... mySpecRunner`

=Run your specification with JUnit4=

To execute your specification with JUnit, you need to use the `JUnit4` class:
{{{
import org.specs.runner.JUnit4

class mySpecTest extends JUnit4(mySpec)
object mySpec extends Specification { ... }
}}}

The name of the test class will be <package name>.mySpecTest

*Note*: we should declare the  JUnit runner as a class and not an object, otherwise Ant and Maven test tasks won't be able to instantiate the class properly. Moreover, following the convention of having 'Test' at the end of the name should be make it being picked up by default.

On the command line, you can run your suite by executing: `java -cp ... org.junit.runner.JUnitCore mySpecTest`

=Run your specification with JUnit4 in Eclipse=

In order to be able to select your JUnit4 classes, you need to add the output directory of your project to your build path:
 # Select your project
 # Go to "Build Path / Configure Build Path"
 # In the "Libraries" tab, "Add Class Folder"
 # In the "Class Folder Selection" dialog, do "Create New Folder"
 # In the "New Folder" dialog, select "Advanced" and "Link to folder in the file system"
 # Select the output folder of your project
 # Refresh your project (F5 on the project's folder)

You should now be able to select the JUnit4 classes of your Scala project.

=Run your specifications with JUnit4 and Maven =

You need to respect the surefire plugin naming convention:
{{{
// all JUnit4 tests must end with "Test"
// it must be a class, not an object, otherwise the class name would be mySpecTest$
class mySpecTest extends JUnit4(mySpec)
object mySpec extends Spec
}}}

Then you run the usual `mvn test` to compile main code, test code and execute the tests.

=Run your specification with JUnit4 and Ant=

You can use the following Ant build file as a starter to compile and execute your specs as JUnit tests:
{{{
<project name="MyFirstSpecsProject" default="test" basedir=".">
  <description>sample build file</description>
  <!-- 1. Define common properties. Change the paths according to your installation -->
  <property name="src.dir" value="src/main/scala" />
  <property name="src.test.dir" value="src/test/scala" />
  <property name="build.dir" value="target/classes" />
  <property name="lib.dir" value="lib" />
  <property name="repository.home" value="c:/local_repository" />
  <property name="scala-compiler.jar"
  value="${repository.home}/org/scala-lang/scala-compiler/2.6.1/scala-compiler-2.6.1.jar" />
  <property name="scala-library.jar"
  value="${repository.home}/org/scala-lang/scala-library/2.6.1/scala-library-2.6.1.jar" />
  <!-- 2. Define Scala CLASSPATH. -->
  <path id="scala.classpath">
    <pathelement location="${scala-compiler.jar}" />
    <pathelement location="${scala-library.jar}" />
  </path>
  <!-- 3. Define project CLASSPATH. -->
  <path id="project.classpath">
    <path refid="scala.classpath" />
    <pathelement location="${build.dir}" />
    <pathelement location="${repository.home}/junit/junit/4.4/junit-4.4.jar" />
    <pathelement location="${repository.home}/org/specs/specs/1.2.3/specs-1.2.3.jar" />
    <pathelement location="${repository.home}/org/scalacheck/scalacheck/1.1.1/scalacheck-1.1.1.jar" />
  </path>
  <!-- 4. Define scala compiler command. -->
  <taskdef resource="scala/tools/ant/antlib.xml">
    <classpath refid="scala.classpath" />
  </taskdef>
  <!-- 5. Compiles sources by using "scalac" command. -->
  <target name="compile">
    <mkdir dir="${build.dir}" />
    <scalac srcdir="${src.dir}" destdir="${build.dir}" classpathref="project.classpath" force="changed">
      <include name="**/*.scala" />
    </scalac>
  </target>
  <target name="test-compile">
    <mkdir dir="${build.dir}" />
    <scalac srcdir="${src.test.dir}" destdir="${build.dir}" classpathref="project.classpath" force="changed">
      <include name="**/*.scala" />
    </scalac>
  </target>

  <!-- 6. Execute the specs as junit tests. -->
  <target name="test" description="execute the tests">
    <junit haltonfailure="true" showoutput="true">
      <classpath refid="project.classpath" />
      <formatter type="brief" usefile="false" />
      <batchtest fork="yes">
        <fileset dir="${build.dir}">
          <include name="**/*Test.class" />
          <exclude name="**/All*Test.class" />
        </fileset>
      </batchtest>
    </junit>
  </target>
  <taskdef name="junit" classname="org.apache.tools.ant.taskdefs.optional.junit.JUnitTask" />
</project>
}}}
(the initial compile script comes from [http://scriptlandia.blogspot.com/2007/04/how-to-compile-and-run-scala-program.html this blog post])


=Run your specifications and get the results as an XML file =

You can use the `XmlRunner` class to export the results of your specifications as an xml file:
{{{
object specResults extends XmlRunner(extendedThrowableUnit)
}}}

This will create a file named extendedThrowableUnit.xml in the current directory: 
{{{
<spec errors="0" description="extendedThrowableUnit" failures="0" assertions="1" name="extendedThrowableUnit">
  <sut errors="0" description="an extended Throwable" failures="0" assertions="1">
    <example errors="0" description="provide a location method extracting the name of the file and the line from an exception" failures="0" assertions="1"></example>
  </sut>
</spec>
}}}

and display:
{{{
Specification "extendedThrowableUnit"
  an extended Throwable should
  + provide a location method extracting the name of the file and the line from an exception

Total for specification "extendedThrowableUnit":
Finished in 0 second, 16 ms
1 example, 1 assertion, 0 failure, 0 error
}}}

It is also possible to specify the output directory with:
{{{
object specResults extends XmlRunner(extendedThrowableUnit, "./target/reports/specs")
}}}

=Run your specification with !ScalaTest=

Declare a runner extending the `ScalaTestSuite` runner:

{{{
import org.specs.runner._
class mySpecSuite extends ScalaTestSuite(mySpec)
}}}

Then use the !ScalaTest gui runner: `java -cp ... org.scalatest.Runner -g -s mySpecSuite`

=Declare several spec runners at once=

You may want to execute a specification with several runners. In that case you can declare:

{{{
import org.specs.runner._
class mySpecRunner extends Runner(mySpec) with JUnit with ScalaTest with Console

// or alternately if you also require an xml output
class mySpecRunner extends Runner(mySpec) with JUnit with ScalaTest with Xml
}}}

The execution of each runner can be done via:
{{{
JUnit4 -> java -cp ... org.junit.runner.JUnitCore mySpecRunner
ScalaTest -> java -cp ... org.scalatest.Runner -g -s mySpecRunner
XmlRunner -> scala -cp ... -e "(new mySpecRunner).reportSpecs"
ConsoleRunner -> scala -cp ... -e "(new mySpecRunner).reportSpecs"
}}}

=Skip examples =

You can skip several examples by using the skip method:
{{{
object mySkippedSpecification extends Specification {
  "These examples" should {
    skip("those examples don't pass yet")
    "be skipped" in {...}
    "be skipped2" in {...}
  }
}
}}}
You can also skip an individual example if a matcher is not satisfied:
{{{
object mySpecification extends Specification {
  "my web framework" should {
    "work with DB2" in {
      // skip the example if the DB2 connection is not available locally
      DB2Connection.start must not(throwA(ConnectionException(""))).orSkipExample // alias orSkip
      // use DB2Connection
    }
    ...
  }
}
}}}

Skipped examples will appear in the Console runner with a small 'o'
{{{
my web framework should
  o work with DB2
    skipped because DB2 cannot connect was thrown
}}}

Otherwise, the skipped examples will be reported in the JUnit reports if using a JUnit4 runner to execute the specs.

=Include or exclude examples=


Most of the time examples are naturally classified and grouped according to the Specification they belong to. However, sometimes you may want to group examples differently in order to execute them separately for instance. One very common use of this is when you want to run one example only inside a Specification containing a lot of other examples. Instead of commenting out the other examples you can:

 * tag the example you want to run 
{{{
  "this example is tagged" in {
    // assertions
  } tag("only this")
}}}

 * accept only the tag you defined on the Specification
{{{
  // other examples will be marked as skipped
  mySpec.accept("only this")
}}}

It is possible also to reject tags in order to exclude some examples:
{{{
  // returns the Specification object so that
  // class SpecTest extends JUnit4(mySpec.accept("tag1")) is valid
  mySpec.accept("only this").reject("still failing") 
}}}

Tags are also applicable to whole systems under specification so that all included examples will also be tagged:
{{{
  "this system" should {
    // lots of examples
  } tag("basic functionalities")
}}}

From the command line, the tags can be accepted or rejected with the following options:

 * `--accept` or `-acc` followed by a comma-separated list of tags 
 * `--reject` or `-rej` followed by a comma-separated list of tags

For example: `scala mySpecification --accept tag1,tag2 --reject tag3`