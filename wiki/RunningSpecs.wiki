#summary How to execute specifications

=Run your specification in the Console=

To execute your specification in a Console you need to use the `ConsoleRunner` class:
{{{
import org.specs.runner.ConsoleRunner

object mySpecRunner extends ConsoleRunner(mySpec)
object mySpec extends Specification { ... }
}}}

===Find specifications in a directory path===

You can use the SpecsFinder class to find specifications in a given path:
{{{
object displaySpecifications extends SpecsFinder with Application {
  // print all specifications contained in subdirectories of the project directory
  // whose names are matching "all.*"
  specificationNames("project/**/*.scala", "all.*") foreach { println(_) }
}
}}}

To be more specific, the name of the specification will be retrieved if the scala file contains:
{{{
\\s*object\\s*(" + pattern + ")\\s*extends\\s*.*Spec.*\\s*\\{"
}}}

===Execute specifications in a directory path===

You simply use the `SpecsFileRunner`, with the parameters required for the `SpecsFinder`:
{{{
import org.specs.runner.SpecsFileRunner

object allSpecsRunner extends SpecsFileRunner("project/**/*.scala", "all.*")
}}}
 
The `SpecsFileRunner` will find possible specification names with the `SpecsFinder` and will try to instantiate them, keeping them only if the resulting object is an instance of `Specification`.

===How to redirect the results on a different output===

If you want to redirect the result of the execution to a file for example, you have to create a new trait extending the `Output` trait:
{{{
trait FileOutput extends Output {
  def println(m: Any) = {...}
  def printf(format: String, args: Any*) = {...}
  def flush() = {...}
}
}}}

And then you "mix" it with the `ConsoleRunner`:
{{{
object mySpecRunner extends ConsoleRunner(mySpec) with FileOutput
object mySpec extends Specification { ... }
}}}

=Run your specification with JUnit3=

To execute your specification with JUnit3, you need to use the `JUnit3` class:
{{{
import org.specs.runner.JUnit3

object mySpecSuite extends JUnit3(mySpec)
object mySpec extends Specification { ... }
}}}

The name of the test class will be <package name>.mySpecSuite$

=Run your specification with JUnit3 in Eclipse=

If you want to execute the JUnit test cases using Eclipse, you have first to create a Java project referencing your Scala project. Then you can use the following JUnit test class to run your JUnit specs suite:
{{{ 
package test;
import junit.framework.*;

public class SpecsJUnitRunner extends TestCase {
	public static Test suite() {
		final String suiteClassName = System.getProperty("scalaSuite");
		try {
			Class<?> suiteClass = Thread.currentThread().getContextClassLoader().loadClass(suiteClassName);
			TestSuite testSuite = (TestSuite) suiteClass.newInstance();
			return (testSuite);
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
		return null;
	} 

}
}}}

You have to run the SpecsJUnitRunner class with the name of your *specs* suite as an argument: {{{-DscalaSuite=scala.specs.mySpecSuite$}}}

=Run your specifications with JUnit3 and Maven =

You need to adopt a naming convention, like this one:
{{{
// all JUnit3 test suites must end with "Suite"
object mySpecSuite extends JUnit3(mySpec)
object mySpec extends Spec
}}}

To run this suite, add this configuration to your pom.xml:
<build>
...
<plugins>
....
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <configuration>
         <includes>
            <include>**/*Suite$.java</include>  <!-- this is a bit meaningless, but surefire replaces .java with .class to instantiate the tests -->
          </includes>
         <excludes>
            <excludes>!!nothing!!</excludes> <!-- this is necessary otherwise surefire will exclude  this pattern: **/*$*-->
          </excludes>
        </configuration>
      </plugin>
...
</plugins>
....
</build>


=Run your specifications and get the results as an XML file =

You can use the XmlRunner class to export the results of your specifications as an xml file:
{{{
object specResults extends XmlRunner(extendedThrowableUnit)
}}}

This will create a file named extendedThrowableUnit.xml in the current directory: 
{{{
<spec errors="0" description="extendedThrowableUnit" failures="0" assertions="1" name="extendedThrowableUnit">
  <sut errors="0" description="an extended Throwable" failures="0" assertions="1">
    <example errors="0" description="provide a location method extracting the name of the file and the line from an exception" failures="0" assertions="1"></example>
  </sut>
</spec>
}}}

and display:
{{{
Specification "extendedThrowableUnit"
  an extended Throwable should
  + provide a location method extracting the name of the file and the line from an exception

Total for specification "extendedThrowableUnit":
Finished in 0 second, 16 ms
1 example, 1 assertion, 0 failure, 0 error
}}}

It is also possible to specify the output directory with:
{{{
object specResults extends XmlRunner(extendedThrowableUnit, "./target/reports/specs")
}}}