#summary How to structure your specifications

=Declare a specification=
You can declare a new specification by extending the Specification class:
{{{
import org.specs._

object newSpecification extends Specification {
}
}}}

A specification is composed of:

 * (optionally) subspecifications (see "Compose a specification")
 * systems specifications (generally one but you can add several ones)

=Specify your system=
You specify your system by simply adding a description followed by the method `should`:
{{{
import org.specs._

object newSpecification extends Specification {
 "my system" should {...}
}
}}}

Then, when you will execute the specification with either the JUnitRunner or the ConsoleRunner, you will see displayed:
{{{
my system should
...rest of the specification
}}}

===Alias for the should keyword===
You can declare several system in a specification. In that case you can, for instance, specify the main functionalities of your system using a `should` method and add another section using ,,can,, for advanced features:
{{{
"For power users, my system" can {...}
}}}


===Without implicit defs===
If you don't want to use Scala's implicit defs for the String class, you can also use:

{{{
declare("my system") should {...}
}}}

===Call a function before or after each example===

This is called setup and teardown in the JUnit world. Although this is contreversial (see [http://jamesnewkirk.typepad.com/posts/2007/09/why-you-should-.html here] for example), you can do it with *specs*, by using `doBefore` and `doAfter`:
{{{
"my system" should { doBefore { resetTheSystem }
  "mess up the system" in {...}
  "and again" in {...}
}
}}}

_Note_: the `usingBefore` and `usingBefore` methods taking a parameterless function are deprecated since they are more verbose for the same effect (from v.1.2.2)

=Specify an example=
You specify an example of what your system is supposed to do by adding a description inside a specified system followed by the method `in`:
{{{
"my System" should {
  "be wonderful" in {...}
  "be elegant" in {...}
}
}}}

===Alias for the in keyword===
If you don't like the `in` keyword, you can replace it with the meaningless operator ,,>>,,:
{{{
"my System" should {
  "be wonderful" >> {...}
}
}}}

===Without implicit defs===
You can also specify an example without using implicits defs:
{{{
declare("my System") should {
  forExample("be wonderful") in {...}
}
}}}

=Compose specifications=

Big specifications can be cut in several sub-specifications:
{{{
object bigSpec extends Specification {
  "this big specification".isSpecifiedBy(
                  basicFunctionalitiesSpec,
                  advancedFunctionalitiesSpec,
                  extensionsSpec)
}
}}}

Alternately, when it makes sense, you can also use `areSpecifiedBy` instead of `isSpecifiedBy`.

When executed, a composed specification will display its results with each sub-specification results being indented:
{{{
  this big specification isSpecifiedBy
    the system basic functionalities are
       the system should
         + say hello
         + say hello world
    the system advanced functionalities are
      ...
}}}

===Change the specification description===

By default the description of a specification, which is displayed in case of a composed specification, is the class name of the specification object (without any `$`).
If you want to set a more meaningful name, you need to override the description attribute:
{{{
object basicFunctionalitiesSpecification extends Specification {
  override var description = "the system basic functionalities are"
}
}}}

=Share examples=

If you want to share examples between systems specifications, you can:

 * define a method returning examples:
{{{
def sharedFunctionalities = {
  "provide functionality 1" in {...}   
  "provide functionality 2" in {...}   
}
}}}

 * use this method inside another example:
{{{
"my system" should {
  "provide common functionalities" in { sharedFunctionalities }
}
}}}

=Concurrent execution=

By default, the execution mode of examples of a Specification is "on demand". The examples are only executed when a Runner requests the number of failures or errors. This enables a runner to do a concurrent execution of examples. 

However, if you need to execute samples sequentially (as in a [http://code.google.com/p/specs/wiki/LiteralSpecifications literal specification]), you can use the method `setSequential`:

{{{
object mySpec extends Specification {
  "The first functionality" should { setSequential

    "have example 1 execute first" in {...}
    // example 2 uses the results of example 1
    "have example 2 execute in second" in {...}
  }
}
}}}