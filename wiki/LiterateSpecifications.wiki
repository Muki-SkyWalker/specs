#summary How to write literate specifications

http://upload.wikimedia.org/wikipedia/commons/thumb/0/01/Nuvola_apps_important.png/20px-Nuvola_apps_important.png *Alpha version!*

<wiki:toc/>

= Why literate specifications? =

The literate specifications support in *specs* is intended to provide a way to develop Acceptance specifications in a [http://fitnesse.org/FrontPage Fitnesse] style.

The basic idea is to define Systems under specification as some informal text, possibly with images. Parts of this text are considered as examples and they are backed up by some Scala code executed against the system being specified. 

Furthermore, *Forms* add a very convenient way to declare and display expected structured information, like business objects (customers, orders,... the usual ones).

== A short example ==

Here is a short example of such a `LiterateSpecification`: 
{{{

class HelloWorldSpecification extends HtmlSpecification {
 
  "The greeting application" is <textile>

h3. Presentation

This new application should say "hello" in different languages.

For example,<ex>by default, saying hello by default should use English</ex> { greet must_== "hello"}
 
Then, other languages, like <ex>French and German should be supported too</ex> 
{ eg {
    greet("French") must_== "bonjour"
    greet("German") must_== "hallo"
  } 
}

<ex>Japanese should be supported also</ex> { notImplemented }

 </textile>
}
}}} 

The example above shows the following features:

 * the `HelloWorldSpecification` is an `HtmlSpecification` which is actually a `LiterateSpecification` mixing-in the `Html` trait to report the execution with an Html runner

 * the name of the first System under specification is "The greeting application" and is defined by an xml Element `<textile></textile>`

 * a title is declared with the `h3.` markup tag, using the [http://en.wikipedia.org/wiki/Textile_(markup_language) Textile] markup language as specified by the name of the xml element. The other supported markup language is [http://en.wikipedia.org/wiki/Markdown Markdown].

 * the first example description is enclosed in the `<ex></ex>` element.

 * it is *immediately* followed by an expectation which is some Scala code enclosed in `{}` curly braces.

 * when there are several expectations, they must be enclosed in a `eg` function to declare that they belong to the same example (otherwise the first expectation would be attached to the example description, the next ones would be anonymous examples)

When you run the example above, the result should be the following [http://specs.googlecode.com/svn/samples/LiterateSpecifications/org.specs.samples.helloWorld.html html]


= Helper functions =

The first helper function seen above is the `notImplemented` function. This will just create an example which body throws a `SkippedException` .

There are other available helper functions:

 * `shh`. To "silence" the result of an expression. If you want to execute an action in the middle of the specification, you can silence it to avoid its result to be printed:
{{{
  This some text { doSomething().shh }
  or This some text { doSomething() <| }
}}}

 * `consoleOutput(messages: Seq[String])`. This displays the messages with a "prompt", mimicking the Scala interpreter (see [http://code.google.com/p/specs/LiterateSpecifications#Scala_interpreter Scala interpreter]

 * `linkTo(description, otherSpecification)`. Links to sub-specifications can be included with the `linkTo` function. This will include the other specification in the current one (if not already present) and create a Html link to its results.

== Display code ==

Sometimes code is not always properly displayed on multiple lines with either Textile or Markdown. The workaround for this is to mixin the Textile or Markdown trait and use the following functions which will also add css coloring: 
{{{
  This is some code to display properly: {
    """
    println("Hello world")
    """ >@
    // or "println("Hello world")".code without a cabalistic sign
  }
}}}

== Simple Properties ==

Sometimes, in order to stay [http://en.wikipedia.org/wiki/Don't_repeat_yourself DRY], you may want to extract part of a description as a property to reuse it in the implementation of the example. Here is an example from the xmlRunnerSpec specification
{{{

It is possible to indicate the output directory of the runner, for example: {"specresults" as runnerOutputDir}
      In that case, {"the xml file should be created in the output directory with path: " +
                 "./specresults/org.specs.runner.sp1.xml".as(path) in checkOutputDirectory}

}}}

In the situation above, the `runnerOutputDir` property will hold the "specresults" values which will also be displayed in the literate specification text.

For your convenience, there are several traits with predefined properties that you can mix-in to your specification to avoid creating Property variables:

 * `StringProperties`: a, b, c, d, e, f
 * `IntProperties`: i, j, k, l, m, n
 * `DoubleProperties`: u, v, w, x, y, z
 * `BooleanProperties`: o, p, q, r, s, t
 * `XmlProperties`: xml, xml2, xml3, xml4, xml5, xml6
 * `CurrentProperty`: it
 * `AllProperties`: all the traits above

All those properties offer an additional shortcut to set the property value:
{{{
... with AllProperties {

  "the age is " + 10.i " + years  // set the property i and display "the age is 10 years"
  "c:/temp".a                     // set the property "a"
  <ex>result<ex>.xml              // set the property "xml"
}
}}}

= Data tables =

[http://code.google.com/p/specs/wiki/AdvancedSpecifications#How_to_use_Data_Tables DataTables] can also be used inside a `LiterateSpecification` with the following syntax:
{{{

 All those small examples should be ok: {
   "examples are ok" inTable 
   "a" | "b" | "sum" |
    1  !  1  ! 2     |
    1  !  2  ! 3     |
    1  !  3  ! 4     | { (a: Int, b: Int, sum: Int) =>
     a + b must be equalTo(sum)
   }
 }

}}}

= Snippets =

Snippets of Scala code can be inserted in the specification by adding the `LiterateSnippets` trait to the `LiterateSpecification`:
{{{
  This is creating a piece of Scala code. The "println("hello")" code is stored in a variable called "it" (stored in the org.specs.specification.SnipIt trait). 
  It is also displayed in the Html report with a code style:
  { "println(\"hello\")" snip it }
  
  This code can then be executed with:
  { execute(it) }

  You can check that the output indeed contains the expected messages with: {
    executeIs("hello") // equivalent to execute(it) must include("hello")
    
    // same thing but adds a small prompt sign before the output text
    >("hello")
    // 
  }

}}}

Note that each call to `snip it` will actually clear the `it` variable. If you want to have some code being kept in the `it` variable you can use the `prelude` method:
{{{
  { """import scala.collection.immutable._
       import scala.xml._
    """ prelude it }

  The prelude method can be called several times
  { """import org.specs.specification._
       import org.specs.util._
    """ prelude it }
}}}

As you can see, this is very useful when declaring shared imports.

For a complete example, please have a look at [http://code.google.com/p/specs/source/browse/trunk/src/test/scala/org/specs/mock/mockitoSpec.scala the Mockito specification] and its [http://specs.googlecode.com/svn/samples/LiterateSpecifications/org.specs.mock.mockitoSpec.html Html report]

= Forms =

Forms are the preferred way in specs to create examples in a table format, so that they are readable by business users.

== Fields ==

A form is a set of Fields or Properties. Here is a simple example of a Form:
{{{
class Person extends Form {
  val firstName = field("First name", "Eric")
  val lastName = field("Last name", "Torreborre")

  tr(firstName)
  tr(lastName)
}
}}}

This form declares 2 fields attached to the Person form (with the `field` method). They have a distinct label and an initial value. They are displayed on 2 separate rows with the tr method.

The following html [http://code.google.com/p/specs/source/browse/samples/LiterateSpecifications/org.specs.samples.fieldFormSpec.html html] is produced with this literate specification: 
{{{
class fieldsFormSpec extends LiterateSpecification with Html {
 class Person extends Form {
   val firstName = field("First name", "Eric")
   val lastName = field("Last name", "Torreborre")
   tr(firstName)
   tr(lastName)
 }
 "A form with fields" is <textile>
   { new Person().toHtml }  
  </textile>
}
}}}

Clearly this Form is not doing much, this is just a way to create a table with input data in the `LiterateSpecification` and to be able to get its values afterwards.

== Properties ==

Now if we want to be able to set expectations on data we need to declare properties. A property is declared like a field, but with the `prop` method (inside a Form object):
{{{
  // "Name" is the property label, "Eric" is its actual value
  val name = prop("Name", "Eric")
}}}

Then it is possible to set the expected value of this property with its `apply` method (see the complete example [http://code.google.com/p/specs/wiki/LiterateSpecifications#Nested_forms below]):
{{{
  name("Bob") // the enclosing Form object will check that actual value == expected value
}}}

=== Value formatters ===

The default formatter for Double values is `new DecimalFormat("#.###############")`, however if you want to have a specific display for some of your values, you can declare a new value formatter on a property. For example, you may want to display Iterable properties (created with the `propIterable` method) with `\` as a separator:
{{{
  p = PropIterable("", List("1.2", "3.4"))
  p.formatIterableWith((list:Option[Iterable[Double]]) => list match { 
     case None => "x/x/x" // this is for the case where there are no values
     case Some(l) => l.map(p.formatValue(_)).mkString("/") // using the default formatter for Doubles, then separating with "/"
  })
}}}

The available formatting methods are:

 * `formatWith` to format values _and_ missing values on properties
 * `formatterIs` to format existing values (an empty string is used for a missing value)
 * `formatIterableWith` to format iterable properties (for both existing _and_ missing values)
 * `iterableFormatterIs` to format only existing values on iterable properties

=== Label and Value decorators ===

On any Field, Prop or Form you can set decorators for labels or values:
{{{
  // this will add bold tags around the formatted value
  myField.decorateValueWith((s:String) => <b>{s}</b>)

  // this will add italic tags around the formatted label
  myField.decorateLabelWith((s:String) => <i>{s}</i>)

  // and there are convenient shortcuts for italics, bold and strike
  myField.italicValue    // the value is italic
  myField.strikeLabel    // the label is strike
  myField.bold           // all is bold

}}}


== Nested forms ==

Let's have a look at a complete example, which will also demonstrate that forms can also be nested to create complex business objects:

First of all, let's define some application-level objects modeling a Person and his address:
{{{
trait PersonBusinessEntities {
  case class Person(firstName: String, lastName: String, address: Address, friends: List[String]) {
    def initials = firstName(0).toString + lastName(0)
  }
  case class Address(number: Int, street: String)
}
}}}

Then let's create a `PersonForm` which can be instantiated from an actual Person object (retrieved from a database for example):
{{{
trait PersonForms extends HtmlSpecification with PersonBusinessEntities {

  case class PersonForm(t: String, p: Person) extends Form(t) {
    def this(p: Person) = this("Customer", p)
    val firstName = prop("First Name", p.firstName)
    val lastName = prop("Last Name", p.lastName)
    val initials = prop("Initials", p.initials).matchesWith(beEqualToIgnoringCase(_))
    val friends =  propIterable("Friends", p.friends)
    val address = form(AddressForm("Home", p.address))

    tr(firstName, address)
    tr(lastName, initials)
    tr(friends)
  }
  case class AddressForm(t: String, address: Address) extends Form(t) {
    def this(a: Address) = this("Home", a)
    val number = prop("Number", address.number)
    val street = prop("Street", address.street)
    tr(number)
    tr(street)
  }
}
}}}

In the 2 forms above, we declare:

 * a title for the form `extends Form(t)`. This will replace the title by default which is  created by uncamelcasing the class name

 * some properties like `firstName`. Those properties have their actual value set from a `p` object passed as a parameter

 * an iterable property which will display its value a bit differently by separating all values with commas

 * a nested form, declared with the `form` method

 * a layout for those properties and forms on 3 different rows with the `tr` method

Finally, we can create a literate specification with this form, like this:
{{{
class formSampleSpec extends PersonForms with Html {
  "Forms can be used in a Literate specificatins" is <textile>

This is a Person form, checking that the initials are set properly on a Person object. { 
  val address = Address(37, "Nando-cho")
  val person = Person("Eric", "Torreborre", address, List("Jerome", "Olivier"))

  "Initials are automatically populated" inForm
   new PersonForm(person) {
    firstName("Eric")       
    initials("et")
    friends("Jerome", "Olivier")
    address.set { a =>
                  a.number(37)
                  a.street("Nando-cho") }
    lastName("Torreborre")
   }
}

  </textile>
}

}}}

When we use the form, we bind it with an actual person object and for each property, we declare what is the expected value. For example, we expect the `initials` property to be properly populated with the initials of the first name and the last name of the Person.

You can also notice the `set` method on a form which provides a way to set a nested form properties in the same block.

When the specification is executed, the result will look like [http://specs.googlecode.com/svn/samples/LiterateSpecifications/org.specs.samples.formSampleSpec.html this].

== Forms execution ==

There are 2 way to relate the form successes/failures to its specification:

 * either you use the `inForm` method as seen above. This will create a new example and one failure if the form fails (but still all the form issues will be displayed)
 
 * or you can just declare the form and call the `report` method on it. This will execute the form and attach each property cell as a separate example on the enclosing specification:
{{{
This is a Person form, checking that the initials are set properly on a Person object. { 
  val address = Address(37, "Nando-cho")
  val person = Person("Eric", "Torreborre", address, List("Jerome", "Olivier"))

   new PersonForm(person) {
    firstName("Eric")       
    initials("et")
    friends("Jerome", "Olivier")
    address.set { a =>
                  a.number(37)
                  a.street("Nando-cho")}
    lastName("Torreborre")
   }.report(this)
}
}}}



== Forms layout ==

===Predefined layouts===
Some special methods can be used to help the layout of Forms:

 * *p(properties/forms)*: adds all the properties/forms on a new table row, with an empty row above as a separator
 * *th1(title)*: adds a small box with a caption inside a row
 * *th2(title)*: adds a bold center header on a new row
 * *th3(title)*: adds a bold left-aligned header on a new row
 * *th3(title, status)*: adds a bold left-aligned header on a new row, colored with a specific status ("success" = green, "failure" = yellow, "error" = red, "skipped" = gray, "value" = white)
 
 * *tabs*. You can display 2 forms on 2 different tabs with:
{{{
  // create a new tabs group
  new tabs() {
    // create a new tab
    new tab("Tab 1") {
       form1
    }
    new tab("Tab 2") {
       form2
    }
  }
}}}

=== Override an existing layout ===

When working with an existing form you may wish to:

 * remove some properties from the layout to simplify it. In this case you can use include/exclude to include or exclude some properties from the display:
{{{
  // the customer form class provides a default layout
  new CustomerForm {
    // exclude the age property
    exclude(age)
  }
}}}

 * reset the whole existing layout with `resetLayout` and provide a new one. 

 * override the `layout(formRows: List[Seq[LabeledXhtml]])` method and provide a different layout:
{{{
  override def layoutRows(formRows: List[Seq[LabeledXhtml]]) = {
    th1(field("Customer id", customer.getId))
    trs(new Form {
        new tabs {
          new tab("Orders") {
            trs(formRows)
          }
          new tab("Customer details") {
            customerDetails.foreach((p: Pair[String, Boolean]) => tr(field(p._1, p._2)))
          }
       }
    }.rows)
  }
}}} 

= Special forms =

== `DataTable` form ==

`DataTables` can also be used in a Form. Here is an example:
{{{
  new TradePrice {
    
    "Value date"    | "NPV_PAY_NOTIONAL"    | "NPV_REC_NOTIONAL"    |
    "6/1/2007"      ! -1732.34              ! 0.0                   |
    "4/30/2008"     ! -580332.88            ! 0.0                   | { (valueDate: String, pay: Double, rec: Double) =>

      tr(valueDate, prop(pricePay(valueDate))(pay), prop(priceRec(valueDate))(rec))
    }
  }.report(this)
}}}

In this example:

 * the `DataTable` is not directly executed (there is no `|>` sign on the right border of the table) but it is reported to the enclosing Specification with `report(this)`.

 * the function executed on each row of the `DataTable` is actually building the Form rows (with the `tr` method)

 * there is an implicit conversion converting a value of type T to a `Field[T]`, so the valueDate can directly be added to the form row `tr(valueDate,....)`

 * we want to check that the expected values declared on the 2nd and 3rd columns are correct, so we create properties on the fly where the actual value is the computed price and the expected value is the value declared inside the table

 * no labels are declared for the fields and properties, they're automatically taken from the `DataTable` header
   
== Table forms ==

Actually a `DataTableForm` is just a special case of a `TableForm`. A `TableForm` is a form containing only `LineForms`. And a `LineForm` is just a set of properties which should be displayed on a row, without their labels (the labels will be used to create the table header).

The `DataTableForm` example above could then be rewritten as: 
{{{
  class PayLine(vDate: String, p: Double, r: Double) extends LineForm {
    val valueDate = field("Value date", vDate)
    val pay = prop(pricePay(valueDate))(p)
    val rec = prop(priceRec(valueDate))(r)
  }
  new TableForm {
    tr(PayLine("6/1/2007", -1732.34, 0.0))
    tr(PayLine("4/30/2008", -580332.88, 0.0))
  }.report(this)
}}}

You can note in this example that there is also an implicit conversion between a Field and its value so you can write `pricePay(valueDate)` instead of `pricePay(valueDate.get)`

== `SeqForm` and `EntityLine` form ==

Those 2 forms are to be used when you want to declare a form where each row is a separate "Entity" (modeling a business object for example) and where the whole table declares a sorted sequence of expected entities. Upon execution, the missing or supplementary rows will be reported. Here is an example: 
{{{
  class CustomerLine extends EntityLineForm[Customer] {

    // the prop method accepts a function here, taking the proper attribute on the "Entity"
    val name = prop("Name", (c: Customer) => c.getName)
    val age = prop("b", (c: Customer) => c.getAge)
  }
  class Customers(actualCustomers: Seq[Customer]) extends SeqForm[T](actualCustomers) {
   // each call to call to expects create a new CustomerLine
   // built with one element of the actualCustomer sequence + the expected values 
   def expect(n: String, a: Int) = line { (customer: Option[T]) => 
      new CustomerLine {
        name(n), age(a) 
      }.entityIs(customer)
    } 
  }

  // example usage
  new Customers(listFromTheDatabase) {
    expect("Eric", 36)
    expect("Bob", 27) 
  }
}}}