#summary How to write literate specifications

http://upload.wikimedia.org/wikipedia/commons/thumb/0/01/Nuvola_apps_important.png/20px-Nuvola_apps_important.png *Alpha version!*

<wiki:toc max_depth="2"/>

= Why literate specifications? =

The literate specifications support in *specs* is intended to provide a way to develop Acceptance specifications in a [http://fitnesse.org/FrontPage Fitnesse] style.

The basic idea is to define Systems under specification as some informal text, possibly with images. Parts of this text are considered as examples and they are backed up by some Scala code executed against the system being specified.

== A short example ==

Here is a short example of such a `LiterateSpecification`: 
{{{

class HelloWorldSpecification extends LiterateSpecification with Html {
 
  "The greeting application" is <textile>

h3. Presentation

This new application should say "hello" in different languages.

For example,<ex>by default, saying hello by default should use English</ex> { greet must_== "hello"}
 
Then, other languages, like <ex>French and German should be supported too</ex> 
{ eg {
    greet("French") must_== "bonjour"
    greet("German") must_== "hallo"
  } 
}

<ex>Japanese should be supported also</ex> { notImplemented }

 </textile>
}
}}} 

The example above shows the following features:

 * the `HelloWorldSpecification` mixes-in the Html trait to report the LiterateSpecification with the Html runner

 * the name of the first System under specification is "The greeting application" and is defined by an xml Element `<textile></textile>`

 * a title is declared with the `h3.` markup tag, using the [http://en.wikipedia.org/wiki/Textile_(markup_language) Textile] markup language as specified by the name of the xml element. The other supported markup language is [http://en.wikipedia.org/wiki/Markdown Markdown].

 * the first example description is enclosed in the `<ex></ex>` element.

 * it is *immediately* followed by an expectation which is some Scala code enclosed in `{}` curly braces.

 * when there are several expectations, they must be enclosed in a `eg` function to declare that they belong to the same example (otherwise the first expectation would be attached to the example description, the next ones would be anonymous examples)

When you run the example above, the result should be the following [http://code.google.com/p/specs/source/browse/samples/LiterateSpecifications/org.specs.samples.helloWorld.html html]


= Helper functions =

The first helper function seen above is the `notImplemented` function. This will just create an example which body throws a `SkippedException` .

There are other available helper functions:

 * `shh`. To "silence" the result of an expression. If you want to execute an action in the middle of the specification, you can silence it to avoid its result to be printed:
{{{
  This some text { doSomething().shh }
  or This some text { doSomething() <| }
}}}

 * `consoleOutput(messages: Seq[String])`. This displays the messages with a "prompt", mimicking the Scala interpreter (see [http://code.google.com/p/specs/LiterateSpecifications#Scala_interpreter Scala interpreter]

 * `linkTo(description, otherSpecification)`. Links to sub-specifications can be included with the `linkTo` function. This will include the other specification in the current one (if not already present) and create a Html link to its results.

= Data tables =

[http://code.google.com/p/specs/wiki/AdvancedSpecifications#How_to_use_Data_Tables DataTables] can also be used inside a `LiterateSpecification` with the following syntax:
{{{

 All those small examples should be ok: {
   "examples are ok" inTable 
   "a" | "b" | "sum" |
    1  !  1  ! 2     |
    1  !  2  ! 3     |
    1  !  3  ! 4     |> { (a: Int, b: Int, sum: Int) =>
     a + b must be equalTo(sum)
   }
 }

}}}

= Snippets =

Snippets of Scala code can be inserted in the specification by adding the `LiterateSnippets` trait to the `LiterateSpecification`:
{{{
  This is creating a piece of Scala code. The "println("hello")" code is stored in a variable called "it" (stored in the org.specs.specification.SnipIt trait). 
  It is also displayed in the Html report with a code style:
  { "println(\"hello\")" snip it }
  
  This code can then be executed with:
  { execute(it) }

  You can check that the output indeed contains the expected messages with: {
    executeIs("hello") // equivalent to execute(it) must include("hello")
    
    // same thing but adds a small prompt sign before the output text
    >("hello")
    // 
  }

}}}

For a complete example, please have a look at [http://code.google.com/p/specs/source/browse/trunk/src/test/scala/org/specs/mock/mockitoSpec.scala the Mockito specification]

= Forms =

Forms are the preferred way in specs to create examples in a table format, so that they are readable by business users.

== Properties ==

A form is a set of Fields or Properties. Here is a simple example of a Form:
{{{
class Person extends Form {
  val firstName = field("First name", "Eric")
  val lastName = field("Last name", "Torreborre")

  tr(firstName)
  tr(lastName)
}
}}}

This form declares 2 fields attached to the Person form (with the `field` method). They have a distinct label and an initial value. They are displayed on 2 separate rows with the tr method.



*TO BE CONTINUED,...*