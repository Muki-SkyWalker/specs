#summary Using Mockito mocks and stubs.

(*from 1.4.4*)

*This is a draft, work in progress!!!!*

= Introduction =

[http://mockito.googlecode.com Mockito] is a mocking library which "lets you write beautiful tests with clean & simple API".

*specs* integrates Mockito expectations and add some syntactic sugar for an even simpler experience of Mockito.

= Usage =

In order to use Mockito mocks in your specification, you need to mix in the Mockito trait.

{{{
  
  object spec extends Specification with Mockito {
    
    val m = mock[java.util.List[String]] // a concrete class would be mocked with: mock(new java.util.LinkedList[String])
    
    // stub a method call with a return value
    m.get(0) returns "one"
  
    // call the method
    m.get(0)
  
    // verify that the call happened, this is an expectation which will throw a FailureException if that is not the case
    m.get(0) was called
    
    // we can also check that another call did not occur
    m.get(1) wasnt called // or m.get(1) was notCalled
                          
  }
 }}}

= Stubbing =

Stubbing values is as simple as calling a method on the mock and declaring what should be returned or thrown: {{{
   
  m.get(1) returns "one"
  m.get(2) throws new Exception("forbidden")

}}}

You can specify different consecutive returned values by appending `thenReturns` or `thenThrows`:{{{

  m.get(1) returns "one" thenReturns "two"
  m.get(2) throws new Exception("forbidden") thenReturns "999"

}}}

= Argument matchers =

The built-in Mockito argument matchers can be used to specify the method arguments for stubbing: {{{

   mockedList.get(anyInt()) returns "element"
   mockedList.get(999) must_== "element"
}}}

Hamcrest matchers can also be used, allowing to create your own Hamcrest matchers: {{{

   // stubbing using hamcrest (let's say IsNull returns your own hamcrest matcher):
   mockedList.contains(argThat(new IsNull)) returns true

}}}

You can even pass specs matchers directly as arguments where the implicit conversion would work: {{{
   mockedList.get(==(123)) returns "one" // ==(_) is an alias for beEqualTo(_)

   // note that the implicit conversion transforming a specs Matcher to a Hamcrest matcher would not work here as the expected type for the contains method is Object
   mockedList.contains(isNull) returns true

}}}

= Verification =

By default Mockito doesn't expect any method to be called. However if your writing interaction-based specifications you want to specify that some methods are indeed called: {{{
  mockedList.get(0)

  mockedList.get(0) was called
  mockedList.get(1) wasnt called
  mockedList.get(2) was notCalled

}}}

If anything fails a new FailureException will be thrown creating a failure for the current example.

== Constraints on call expectations ==

You can be more precise when specifying the number of calls on a mock: {{{
  val mockedList = mock[List[String]]

  mockedList.add("one")
  2.times { i => mockedList.add("two") } 
  3.times { i => mockedList.add("three") } 
  
  mockedList.add("one") was called.once
  mockedList.add("two") was called.twice
  mockedList.add("two") was called.atLeastOnce
  // fails with The method was not called as expected: list.add("one"); Wanted 2 times but was 1
  mockedList.add("one") was called.twice

  // It is also possible to check that there are no unexpected calls on a mock:
  mockedList had noMoreCalls

}}}
