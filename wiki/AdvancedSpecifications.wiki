#summary How to use DataTables and syntactic sugar to write more concise examples

= How to use !DataTables=

Suppose you want to specify that a directory path and a file name should be combined to provide a proper full path. One way to specify this is to provide examples of different possible combinations and results (taken from the xmlRunnerUnit specification):
{{{
    "create an xml file in the specified output directory, handling file separators" in {
       "output dir" | 	"spec name" | 	"file path"  		|>
       ""           ! 	"spec1"     !	"./spec1.xml"		|  
       "result"     !	"spec1"     !	"./result/spec1.xml" 	|  
       "result/"    !	"spec1"     !	"./result/spec1.xml" 	|  
       "result\\"   !	"spec1"     !	"./result/spec1.xml" 	|  
       "/result"    !	"spec1"     !	"/result/spec1.xml" 	|
       "\\result"   !	"spec1"     !	"/result/spec1.xml" 	|
       "result/xml" ! 	"spec1"     !	"./result/xml/spec1.xml"| {
       (dir: String, 	spec: String, 	result: String) => {
           xmlRunner.outputDir = dir
           spec1.name = spec
           xmlRunner.execute
           xmlRunner.files must haveKey(result)
         }
       }
       
    }
}}}

In the example above, you have a !DataTable with:
 * a header describing the content of the columns
 * rows being valid combinations
 * a function which applied to each row, specifies the expected behavior

The resulting output in case of a failure would be:
{{{
 |"output dir" | "spec name" | "file path"           |
x|"wrong"      | "spec1"     | "./spec1.xml"         | Map(./bad/spec1.xml -> <...>) hasn't key './spec1.xml'  
 |"result"     | "spec1"     | "./result/spec1.xml"  |  
}}}

Please note the small `>` on the border of the table. This is what makes the table being actually executed in the specification. Think about it a the "play" command (it can be placed on any row).

= How to add syntactic sugar to your specifications =

When you import `org.specs.Sugar._` you get some syntactic sugar that you can add to enhance your specifications:

 * tuples can behave as lists: `(1, 2, 3).tail must_== List(2, 3)`
 * you can use a `times` method to iterate on a block of code:
{{{  
3.times {println _}

var j = 0
3 times {j += _}
j mustBe 6
}}}  
 * println any object with `myObject.println` or `myObject.pln`. If you want the myObject to be printed _and_ returned you can use `myObject.pp` ("print and pass")
 * you can use the constants `ok` and `ko` as equivalents of `true` and `false`
 * you can wait for a certain amount of time mixing the `WaitFor` trait and using the `waitFor` method: `waitFor(10.ms)`