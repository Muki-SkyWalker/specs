#summary how to use jMock in your specs
This page is under construction

= Introduction =

[http://www.jmock.org/ jMock2] allows to define mocks and expectations on mocks very easily.

This page shows how to use jMock with specs. Please refer to the jMock site for more instructions on jMock itself.

= Libraries =

In order to use jMock2 with specs, you need to add the following dependencies to your project: jmock-2.4.0, hamcrest-1.1 and cglib-2.1_3 + objenesis-1.0 if you want to mock classes. Here is a sample maven snippet to realize this
{{{
    <dependency>
      <groupId>org.jmock</groupId>
      <artifactId>jmock</artifactId>
      <version>2.4.0</version>
    </dependency>
    <!-- included for documentation but redundant since they are a dependency of jmock-2.4.0
    <dependency>
      <groupId>org.hamcrest</groupId>
      <artifactId>hamcrest-core</artifactId>
      <version>1.1</version>
    </dependency>
    <dependency>
      <groupId>org.hamcrest</groupId>
      <artifactId>hamcrest-library</artifactId>
      <version>1.1</version>
    </dependency>
    -->   
    <!-- Those are only needing if you want to mock classes -->
    <dependency>
      <groupId>cglib</groupId>
      <artifactId>cglib</artifactId>
      <version>2.1_3</version>
    </dependency>
    <dependency>
      <groupId>org.objenesis</groupId>
      <artifactId>objenesis</artifactId>
      <version>1.0</version>
    </dependency>
}}}

= A simple mock example with specs and jMock =

Using mocks follows a 4 steps process:

   1. extend the JMocker trait and add ClassMocker if you want to mock classes as well as interfaces:
{{{
import scala.specs.mock._
object mySpec extends Specification with JMocker with ClassMocker {...}
}}}
*Tt is especially important that JMocker is mixed-in with your Specification, otherwise the expectations won't be checked*

   2. create mock objects using the `mock` method
{{{
object mySpec extends Specification with JMocker with ClassMocker {
  "my system" should {
    "use mocks" in {
      val mockedService = mock(classOf[Service])
    }
  }
}
}}}

   3. add expectations in your specification example
{{{
object mySpec extends Specification with JMocker with ClassMocker {
  "my system" should {
    "use mocks" in {
      val mockedService = mock(classOf[Service])
      expect {
        one(mockedService).executeService() // this will be called one time exactly
      }
      ...
    }
  }
}
}}}
   4. use the mock in the rest of your example, expectations will be automatically checked at the end of the example 

=A complete example=

Here is a complete example of the use of mocks to specify the interactions between a `Button` and a `Light` object:
{{{
trait ButtonAndLightMock extends ButtonAndLight with JMocker with ClassMocker {
  val mock = mock(classOf[Light])
  val button = Button(mock)
}
trait ButtonAndLight {
  case class Button(light: Light) {
    var lightOn = false
    def push = {
      if (lightOn) light.off else light.on 
      lightOn = !lightOn
    }
  }
  case class Light {
    var state: LightState = Off
    def on = state = On
    def off = state = Off
    def isOn = state == On
  }
  abstract sealed class LightState(s: String)
  case class On extends LightState("on")
  case class Off extends LightState("off")
}

object mockExample extends Specification with ButtonAndLightMock {
  "A button and light mock example" should {
    "not fail if the mock receives the expected messages" in {
      expect {
        one(mock).on
        one(mock).off
      }
      button.push
      button.push  // if the button is pressed twice, then the light will go on and off
    }
  }
}
}}}

= Methods expectations =

==Methods counters==
All the standard jMock method expectations are available with specs. However, a little bit of syntactic sugar has been added:
{{{
  expect {
    exactly(2).of(mock).on // is equivalent to 
    2.of(mock).on

    atLeast(2).of(mock).on // is equivalent to 
    2.atLeastOf(mock).on

    (2 to 4).of(mock).on // between 2 and 4 calls to list.size
  }
}}}

==Allowing or ignoring methods==

Some shortcuts are available to allow or ignore some method calls:
{{{
  expect {
    allowingMatch("on") // allow any method matching "on"
    allowingMatch(mock, "on") // allow any method matching "on" on the mock object
    ignoringMatch("on") // ignore any method matching "on"
    ignoringMatch(mock, "on") // ignore any method matching "on" on the mock object
  }
}}}

==Returned values==

Scala allows a more natural definition of returned values on mock expectations with `will`, `willReturn` and `willReturnIterable`:
{{{
expect { 
  one(List("hey")).take(anyInt) will returnValue(equal(List("hey"))) // `will` accepts a jMock action, like returnValue
  one(List("hey")).take(anyInt) willReturn List("hey") // `willReturn` specifies a returned value
 one(List("hey")).take(anyInt) willReturnIterable("a", "b") // `willReturnIterable` will return an Iterable whose values are given as varargs parameters
}
}}}

==Returned values on consecutive calls==

specs offers a shortcut to specify that consecutive calls to a given method will return different values:
{{{
  1.atLeastOf(list).get(anyInt) willReturnEach ("a", "b", "c") // returns "a" the first time the "get" method is called, "b" the second time and "c" the third time
}}}

==Nested returned values and mocks==

This is a frequent situation when interacting with object graphs. You need to mock an object, like a Connection, which is supposed to give you access to a service, that you want to mock also and so on. For example, testing some code accessing the Eclipse platform can be very difficult for that reason. 

Using specs you can declare:
{{{
  // A workspace gives access to a project and a project to a module
  case class Module(name: String)
  case class Project(module: Module, name: String)
  case class Workspace(project: Project)
  val workspace = mock(classOf[Workspace])
  
  expect { 
    // define nested expectations on the workspace, the project and the module
    one(workspace).project.willReturn(classOf[Project]) {p: Project => 
        one(p).name willReturn "hi"
        one(p).module.willReturn(classOf[Module]) {m: Module => 
          one(m).name willReturn "module"}
    }
  }

}}}

or

{{{
  // a workspace is a list of projects
  case class Project(name: String)
  case class Workspace(projects: List[Project])
  val workspace = mock(classOf[Workspace]) 
  expect { 
    // the workspace will return project mocks with different expectations
    one(workspace).projects willReturnIterable(classOf[Project], 
           {p: Project => one(p).name willReturn "p1" },
           {p: Project => one(p).name willReturn "p2" })
  }

}}}

==Thrown exceptions==

You can declare that a method call will throw an exception with `willThrow`:
{{{
expect { 
  one(list).get(will(be_==(0))) willThrow new java.lang.Exception("ouch") 
}
}}}