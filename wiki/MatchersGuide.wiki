#summary to be finished...

=Matchers presentation=

There are different kind of matchers which are used to assert that some properties must be verified. Generally they are used like this:

{{{
"This example presents a matcher" in {
  // myObjectOfTypeT is an object of type T
  // verifyThisMatcherWith is a Matcher[T]
  myObjectOfTypeT must verifyThisMatcherWith(value)
}
}}}

===Create your own Matcher===

Creating a new Matcher is easy. You extend the `AbstractMatcher` class and implement the `apply` method:

{{{
class CustomMatcher extends AbstractMatcher {
  // the apply method must return a Tuple[Boolean, String, String]
  def apply[T](v: T) = (booleanFunction(v), "okMessage", "koMessage")
}
}}} 

===Create the negation of a matcher===

Simply use the `not` method on a matcher:

{{{
val beOdd = beEven.not
}}}

In that case, the ok message of the first matcher is used as a ko message and vice-versa.

===Combine matchers===

You can combine matchers with logical operators: `and`, `or`, `xor`, `verifyAll`, `verifyAny`

{{{
  "ab" must beMatching("a") and beMatching("b")
  "ab" must beMatching("a") or beMatching("c")
  "ab" must beMatching("a") xor beMatching("c")
  "ab" must verifyAll(beMatching("a"), beMatching("b"))
  "ab" must verifyAny(beMatching("a"), beMatching("b"))
}}}

`verifyAll` must be ok for all matchers and `verifyAny` must be ok for at least one matcher.

=Matchers applicable to any object=

 * `a must be(b)` is ok if `a eq b` (alias: `a mustBe b` or `a mustEq b`)
 * `a must notBe(b)` is ok if `!(a eq b)` (alias: `a must notEq(b)` or `a mustNotBe(b)`)

 * `a must be_==(b)` is ok if `a == b` (alias: `a must_== b` or `a mustEqual b`)
 * `a must be_!=(b)` is ok if `a != b` (alias: `a must_!= b`)

 * `a must beIn(iterable)` is ok if `iterable.exists(_ == a)`
 * `a must notBeIn(iterable)` is ok if `!iterable.exists(_ == a)`

 * `a must beEmpty` is ok if `a` defines a `isEmpty` method and `a.isEmpty`
 * `a must notBeEmpty` is ok if `a` defines a `isEmpty` method and `!a.isEmpty`

 * `a must verify(f)` is ok if `f(a) == true` (alias: `a mustVerify f` or `a verifies b`)

===If you want to verify that an exception is thrown===

 * `a must throwA(new Exception)` is ok if evaluating `a` throws a Exception (alias: `throwAn`)
 * `a must throwA(new Exception)like {case Exception(m) => m.startsWith("bad")} ` is ok if evaluating `a` throws an Exception and the message starts with "bad"

 * `a must throwThis(new Exception("message"))` is ok if evaluating `a` throws an exception e and `e == new Exception("message")`
 
=Matchers applicable to Strings=
 
 * `a must equalIgnoreCase(b)` is ok if `a equalsIgnoreCase(b)` (alias: `a must_==/ b`)
 * `a must notEqualIgnoreCase(b)` is ok if `!(a equalsIgnoreCase(b))` (alias: `a must_!=/ b`)

 * `a must beMatching(b)` is ok if a matches the regexp b (alias: `a mustMatch b`)
 * `a must notBeMatching(b)` is ok if a doesn't match the regexp b (alias: `a mustNotMatch b`)

 * `a must include(b)` is ok if `a.indexOf(b) >= 0`
 * `a must notInclude(b)` is ok if `a.indexOf(b) < 0`

 * `a must startWith(b)` is ok if `a startsWith b`
 * `a must notStartWith(b)` is ok if `!(a startsWith b)`

 * `a must endWith(b)` is ok if `a endsWith b`
 * `a must notEndWith(b)` is ok if `!(a endsWith b)`

=Matchers applicable to Iterables=
 
 * `a must contain(b)` is ok if `a.exists(_ == b)`
 * `a must notContain(b)` is ok if `!a.exists(_ == b)`

 * `a must exist(f)` is ok if a contains an element verifying the function f
 * `a must notExist(f)` is ok if a doesn't contain an element verifying the function f

 * `a must containMatch(b)` is ok if a contains a String matching the pattern `b` (alias: `existMatch`)
 * `a must notContainMatch(b)` is ok if a doesn't contain a String matching the pattern `b` (alias: `notExistMatch`)

 * `a must haveTheSameElementsAs(b)` is ok if a contains the same elements as the iterable b. This verification doesn't check the order of the elements but does a recursive verification is a and b contain iterables: {{{
List(1, List(2, 3, List(4)), 5) must haveTheSameElementsAs(List(5, List(List(4), 2, 3), 1))
}}}


This page will present all the other matchers:
  * matchers for iterables (collections)
  * matchers for numerics
  * matchers for Options (Scala-specific)
  * Scalacheck matchers
  * pattern matchers
 
 