#summary to be finished...

=Matchers presentation=

There are different kind of matchers which are used to assert that some properties must be verified. Generally they are used like this:

{{{
"This example presents a matcher" in {
  // myObjectOfTypeT is an object of type T
  // verifyThisMatcherWith is a Matcher[T]
  myObjectOfTypeT must verifyThisMatcherWith(value)
}
}}}

===Create your own Matcher===

Creating a new Matcher is easy. You extend the `AbstractMatcher` class and implement the `apply` method:

{{{
class CustomMatcher extends AbstractMatcher {
  // the apply method must return a Tuple[Boolean, String, String]
  def apply[T](v: T) = (booleanFunction(v), "okMessage", "koMessage")
}
}}} 

===Create the negation of a matcher===

Simply use the `not` method on a matcher:

{{{
val beOdd = beEven.not
}}}

In that case, the ok message of the first matcher is used as a ko message and vice-versa.

===Combine matchers===

You can combine matchers with logical operators: `and`, `or`, `xor`, `verifyAll`, `verifyAny`

{{{
  "ab" must beMatching("a") and beMatching("b")
  "ab" must beMatching("a") or beMatching("c")
  "ab" must beMatching("a") xor beMatching("c")
  "ab" must verifyAll(beMatching("a"), beMatching("b"))
  "ab" must verifyAny(beMatching("a"), beMatching("b"))
}}}

`verifyAll` must be ok for all matchers and `verifyAny` must be ok for at least one matcher.

===Limit the applicability of a matcher===

In some cases, you may want to specify that a matcher is only applicable depending on some conditions:
{{{
 "abc" must beMatching(s).when(s == ".")
 "abc" must beMatching(s).unless(s.isEmpty)
}}}

=Matchers applicable to any object=

 * `a must be(b)` is ok if `a eq b` (alias: `a mustBe b` or `a mustEq b`)
 * `a must notBe(b)` is ok if `!(a eq b)` (alias: `a must notEq(b)` or `a mustNotBe(b)`)

 * `a must be_==(b)` is ok if `a == b` (alias: `a must_== b` or `a mustEqual b`)
 * `a must be_!=(b)` is ok if `a != b` (alias: `a must_!= b`)

 * `a must beIn(iterable)` is ok if `iterable.exists(_ == a)`
 * `a must notBeIn(iterable)` is ok if `!iterable.exists(_ == a)`

 * `a must beEmpty` is ok if `a` defines a `isEmpty` method and `a.isEmpty`
 * `a must notBeEmpty` is ok if `a` defines a `isEmpty` method and `!a.isEmpty`

 * `a must verify(f)` is ok if `f(a) == true` (alias: `a mustVerify f` or `a verifies b`)

 * `a must beLike { case p => booleanFunction }` is ok if a matches the pattern `p` and the booleanFunction returns true:

{{{
List(1, 2) must beLike { case x::y::Nil => true }
}}}

===If you want to verify that an exception is thrown===

 * `a must throwA(new Exception)` is ok if evaluating `a` throws a Exception (alias: `throwAn`)
 * `a must throwA(new Exception)like {case Exception(m) => m.startsWith("bad")} ` is ok if evaluating `a` throws an Exception and the message starts with "bad"

 * `a must throwThis(new Exception("message"))` is ok if evaluating `a` throws an exception e and `e == new Exception("message")`
 
=Matchers applicable to Strings=
 
 * `a must equalIgnoreCase(b)` is ok if `a equalsIgnoreCase(b)` (alias: `a must_==/ b`)
 * `a must notEqualIgnoreCase(b)` is ok if `!(a equalsIgnoreCase(b))` (alias: `a must_!=/ b`)

 * `a must beMatching(b)` is ok if a matches the regexp b (alias: `a mustMatch b`)
 * `a must notBeMatching(b)` is ok if a doesn't match the regexp b (alias: `a mustNotMatch b`)

 * `a must include(b)` is ok if `a.indexOf(b) >= 0`
 * `a must notInclude(b)` is ok if `a.indexOf(b) < 0`

 * `a must startWith(b)` is ok if `a startsWith b`
 * `a must notStartWith(b)` is ok if `!(a startsWith b)`

 * `a must endWith(b)` is ok if `a endsWith b`
 * `a must notEndWith(b)` is ok if `!(a endsWith b)`

=Matchers applicable to Iterables=
 
 * `a must contain(b)` is ok if `a.exists(_ == b)` (alias: `mustContain`)
 * `a must notContain(b)` is ok if `!a.exists(_ == b)` (alias: `mustNotContain`)

 * `a must exist(f)` is ok if a contains an element verifying the function f (alias: `mustExist`)
 * `a must notExist(f)` is ok if a doesn't contain an element verifying the function f (alias: `mustNotExist`)

 * `a must containMatch(b)` is ok if a contains a String matching the pattern `b` (alias: `existMatch`, `mustExistMatch`, `mustHaveMatch`)
 * `a must notContainMatch(b)` is ok if a doesn't contain a String matching the pattern `b` (alias: `notExistMatch`, `mustNotExistMatch`, `mustNotHaveMatch`)

 * `a must haveTheSameElementsAs(b)` is ok if a contains the same elements as the iterable b. This verification doesn't check the order of the elements but does a recursive verification is a and b contain iterables: 
{{{
List(1, List(2, 3, List(4)), 5) must haveTheSameElementsAs(List(5, List(List(4), 2, 3), 1))
}}}

=Matchers applicable to Maps=
 
 * `m must haveKey(k)` is ok if `map.exists(p => p._1 == k)`
 * `m must notHaveKey(k)` is ok if `!map.exists(p => p._1 == k)`

 * `m must haveValue(v)` is ok if `map.exists(p => p._2 == v)`
 * `m must notHaveValue(v)` is ok if `!map.exists(p => p._2 == v)`

 * `m must havePair(p)` is ok if `map.exists(p == _)`
 * `m must notHavePair(p)` is ok if `!map.exists(p == _)`

=Matchers applicable to numerical values=
 
 * `a must beGreaterThan(b)` is ok if `a >= b`
 * `a must beStrictlyGreaterThan(b)` is ok if `a > b`

 * `a must beLessThan(b)` is ok if `a <= b`
 * `a must beStrictlyLessThan(b)` is ok if `a < b`

 * `a must closeTo(b, delta)` is ok if `b - delta <= a <= b + delta`

=Matchers applicable to Options=
 
 * `a must beNone` is ok if a is None
 * `a must beSome[Type]` is ok if a is Some(t: Type)
 * `a must beSomething` is ok if a is Some(a: Any)

 * an Option matcher can be extended with a `which` condition

{{{
  Some(x) must beSome[String].which(_.startWith("abc"))
}}}

=Matchers applicable to [http://code.google.com/p/scalacheck Scalacheck] properties=

Let's say you want to implement a function which returns all the prefixes of a given list:

{{{
prefixes(List(1, 2, 3)) // => List(List(1), List(1, 2), List(1, 2, 3))
}}}

You can use Scalacheck generators to generate lists of random size: 
{{{
  // list is an arbitrary list (with at least one element)
  // prefix is a random prefix of list
  // testData contains all the prefixes of list and a random prefix
  val testData = for (list <- listOf1(elements(1, 2, 3, 4));
                               n <- choose(1, list.size-1);
                               val prefix = list.take(n))
                            yield (prefixes(list), prefix)
      
  // the generated data must pass the following property
  testData must pass { t: (List[List[Int]], Seq[Int]) => val (prefixes, prefix) = t
    prefixes must contain(prefix)
  }
}}}

 * You can also use a simple boolean function `prefixes.exist(_ == prefix)` instead of 
   the above matcher. The failure message will be however less precise

 * You can express things the other way around: 

`property must pass(data)` instead of `data must pass(property)`

 * You can display Scalacheck messages with `display` on the Console:

{{{
data must pass {
...
}(display)
}}} 

 * You can set Scalacheck properties with `set` (or `display` to additionally see the result on the Console):

{{{
data must pass {
...
}(set(minSize -> 10, maxSize -> 20, maxDiscarded -> 30, minTestsOk -> 5))
}}} 

where:

 * `minSize` is the minimum size for generated data (like lists)
 * `maxSize` is the maximum size for generated data (like lists)
 * `maxDiscarded` is the maximum number of tests which should be inconclusive in order for the property to pass
 * `minTestsOk` is the minimum number of tests which should be ok in order for the property to pass

 * the default is: `minTestsOk->100, maxDiscarded->500, minSize->0, maxSize->100`