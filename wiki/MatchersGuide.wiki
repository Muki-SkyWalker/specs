#summary to be finished...

=Matchers presentation=

There are different kind of matchers which are used to assert that some properties must be verified. Generally they are used like this:

{{{
"This example presents a matcher" in {
  // myObjectOfTypeT is an object of type T
  // verifyThisMatcherWith is a Matcher[T]
  myObjectOfTypeT must verifyThisMatcherWith(value)
}
}}}

=Create your own Matcher=

Creating a new Matcher is easy. You extend the `AbstractMatcher` class and implement the `apply` method:

{{{
class CustomMatcher extends AbstractMatcher {
  // the apply method must return a Tuple[Boolean, String, String]
  def apply[T](v: T) = (booleanFunction(v), "okMessage", "koMessage")
}
}}} 

=Matchers applicable to any object=

 * `a must be(b)` is ok if `a eq b` (alias: `a mustBe b`)
 * `a must notBe(b)` is ok if `!(a eq b)` (alias: `a must notEq(b)`)
 * `a must be_==(b)` is ok if `a == b` (alias: `a must_== b`)
 * `a must be_!=(b)` is ok if `a != b` (alias: `a must_!= b`)
 * `a must beIn(iterable)` is ok if `iterable.exists(_ == a)`
 * `a must notBeIn(iterable)` is ok if `!iterable.exists(_ == a)`
 * `a must beEmpty` is ok if `a` defines a `isEmpty` method and `a.isEmpty`
 * `a must notBeEmpty` is ok if `a` defines a `isEmpty` method and `!a.isEmpty`
 * `a must verify(f)` is ok if `f(a) == true`

=If you want to verify that an exception is thrown=

 * `a must throwA(new Exception)` is ok if evaluating `a` throws a Exception (alias: `throwAn`)
 * `a must throwA(new Exception)like {case Exception(m) => m.startsWith("bad")} ` is ok if evaluating `a` throws an Exception and the message startWith "bad"
 * `a must throwThis(new Exception("message"))` is ok if evaluating `a` throws an exception e and `e == new Exception("message")`
 * 



This page will present all different matchers:
  * matchers for any object like `be_==`
  * matchers for strings
  * matchers for iterables (collections)
  * matchers for numerics
  * matchers for Options (Scala-specific)
  * Scalacheck matchers
  * pattern matchers
 
 