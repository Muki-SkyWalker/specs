#summary How to add assertions to your examples

=Matchers presentation=

There are different kind of matchers which are used to assert that some properties must be verified. Generally they are used like this:

{{{
"This example presents a matcher" in {
  // verifyThisProperty is a Matcher
  myObject must verifyThisProperty(parameter)
}
}}}

 * [http://code.google.com/p/specs/wiki/MatchersGuide#Create_your_own_Matcher Create your own matcher]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#Combine_matchers Combine matchers]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#Matchers_applicable_to_any_object Matchers applicable to any object]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#If_you_want_to_verify_that_an_exception_is_thrown Matchers for exceptions]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#Matchers_applicable_to_Iterables Iterables matchers]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#Matchers_applicable_to_Maps Maps matchers]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#Matchers_applicable_to_numerical_values Numerical matchers]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#Matchers_applicable_to_Options Option matchers]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#Matchers_applicable_to_properties ScalaCheck matchers]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#Matchers_applicable_to_XML XML matchers]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#Matchers_applicable_to_Paths_and_Files File matchers]
 * [http://code.google.com/p/specs/wiki/MatchersGuide#Matchers_composition_for_object_graphs Matchers for object graphs]
 * (*from 1.3.2*) [http://code.google.com/p/specs/wiki/MatchersGuide#Precise_failures Precise failures] 
 * [http://code.google.com/p/specs/wiki/MatchersGuide#xUnit_assertions xUnit assertions]

===Create your own Matcher===

Creating a new Matcher is easy. You extend the `Matcher` class, using a case class and implement the `apply` method:

{{{
  "A matcher" can {
    "be created as a case class" in {
      case class matchHello(a: String) extends Matcher[String]() {
        def apply(v: => String) = (v == a, "okMessage", "koMessage")
      }
      "hello" must matchHello("hello")
    }
  }
}}} 

You must return a tuple containing:

 * a boolean value indicating a success or a failure when applied to the object which `must` match
 * a message which can be displayed in case of a success
 * a message which can be displayed in case of a failure

A matcher can also be created through as a val:

{{{
  "A matcher" can {
    "be created as a val" in {
      val beEven = new Matcher[Int] {
        def apply(number: => Int) = {
          val b = number
         (b % 2 == 0, b + " is even", b + " is odd")
        }
      }
      2 must beEven
    }
  }
}}}

Or through a method:
{{{
  "A matcher" can {
    "be created as a method" in {
      def divide(a: Int) = new Matcher[Int] {
        def apply(number: => Int) = {
          val b = number
          (a % b == 0, b + " divides " + a, b + " doesn't divide " + a)
        }
      }
      10 must divide(100)
      3 must not(divide(100))
    }
  }
}}}

_Implementation note: in the above examples, the lazy parameter to the apply method is passed to a local val. This avoids unnecessary evaluations when the parameter is also reused to create the result messages._

===Create the negation of a matcher===

Simply use the `not` method on a matcher:

{{{
 2 must beEven
 val beOdd = beEven.not
 3 must beOdd
}}}

In that case, the ok message of the first matcher is used as a ko message for the second matcher.

===Combine matchers===

You can combine matchers with logical operators: `and`, `or`, `xor`, `verifyAll`, `verifyAny`

{{{
  "ab" must beMatching("a") and beMatching("b")
  "ab" must beMatching("a") or beMatching("c")
  "ab" must beMatching("a") xor beMatching("c")
  "ab" must verifyAll(beMatching("a"), beMatching("b"))
  "ab" must verifyAny(beMatching("a"), beMatching("b"))
}}}

`verifyAll` must be ok for all matchers and `verifyAny` must be ok for at least one matcher.

===Limit the applicability of a matcher===

In some cases, you may want to specify that a matcher is only applicable depending on some conditions:
{{{
 "abc" must beMatching(s).when(s == ".")
 "abc" must beMatching(s).unless(s.isEmpty)
}}}

=Matchers applicable to any object=

 * `a must be(b)` is ok if `a eq b` (alias: `a mustBe b` or `a mustEq b`)
 * `a must notBe(b)` is ok if `!(a eq b)` (alias: `a must notEq(b)` or `a mustNotBe(b)`)

 * `a must be_==(b)` is ok if `a == b` (alias: `a must_== b` or `a mustEqual b`)
 * `a must be_!=(b)` is ok if `a != b` (alias: `a must_!= b`)

 * `a must beEqual(b)` is ok if `a == b` and constrains a and b to have the same type at compilation time. Note that there is still a typing issue if you write

{{{
List(1) must beEqual(List(1)) // compilation error: expecting Matcher[Iterable[Int]] got Matcher[List[Int]]
}}}

However, this works:

{{{
val list: Iterable[Int] = List(1)
List(1) must beEqual(list)
}}}


 * `a must beDifferent(b)` is ok if `a != b` and constrains a and b to have the same type at compilation time

 * `a must beIn(iterable)` is ok if `iterable.exists(_ == a)`
 * `a must notBeIn(iterable)` is ok if `!iterable.exists(_ == a)`

 * `a must beEmpty` is ok if `a` defines a `isEmpty` method and `a.isEmpty`
 * `a must notBeEmpty` is ok if `a` defines a `isEmpty` method and `!a.isEmpty`

 * `a must verify(f)` is ok if `f(a) == true` (alias: `a mustVerify f` or `a verifies b`)

 * `a must beLike { case p => booleanFunction }` is ok if a matches the pattern `p` and the booleanFunction returns true:

{{{
List(1, 2) must beLike { case x::y::Nil => true }
}}}

 * `a must beNull` is ok if a is null
 * `a must notBeNull` is ok if a is not null
 * `a must beAlsoNull(b)` is ok if a is null when b is null or a is not null when b is null

 * `a must haveClass(c)` is ok if a.getClass == c
 * `a must notHaveClass(c)` is ok if a.getClass != c
 * `a must haveSuperClass(c)` is ok if c.isAssignableFrom a.getClass
 * `a must notHaveSuperClass(c)` is ok if !(c.isAssignableFrom a.getClass)
 * `c1 must beAssignableFrom(c2)` is ok if c1 isAssignableFrom c2
 * `c1 must notBeAssignableFrom(c2)` is ok if !(c1 isAssignableFrom c2)

You can also introduce a failure with the `fail` function:

 * `fail("not implemented yet")`

===If you want to verify that an exception is thrown===

 * `a must throwA(new Exception)` is ok if evaluating `a` throws a Exception (alias: `throwAn`)
 * `a must throwA(new Exception)like {case Exception(m) => m.startsWith("bad")} ` is ok if evaluating `a` throws an Exception and the message starts with "bad"

 * `a must throwThis(new Exception("message"))` is ok if evaluating `a` throws an exception e and `e == new Exception("message")`
 
=Matchers applicable to Strings=
 
 * `a must equalIgnoreCase(b)` is ok if `a equalsIgnoreCase(b)` (alias: `a must_==/ b`)
 * `a must notEqualIgnoreCase(b)` is ok if `!(a equalsIgnoreCase(b))` (alias: `a must_!=/ b`)
 * `a must equalIgnoreSpace(b)` is ok if `a.trim == b.trim`
 * `a must notEqualIgnoreSpace(b)` is ok if `a.trim != b.trim`
 * `a must beMatching(b)` is ok if a matches the regexp b (alias: `a mustMatch b`)
 * `a must notBeMatching(b)` is ok if a doesn't match the regexp b (alias: `a mustNotMatch b`) 
 * `a must find(regexp)` is ok if the regular expression finds some groups in a (using `java.util.regex.Pattern.compile(a).matcher(b).find()`). For example: `"lallbl" must find("l(.*?)l")`
 * `a must find(regexp).withGroups(g1, g2)` is ok if the regular expression finds the groups g1 and g2 in a. For example: `"lallbl" must find("l(.*?)l").withGroups("a", "b")`

 * `a must include(b)` is ok if `a.indexOf(b) >= 0`
 * `a must notInclude(b)` is ok if `a.indexOf(b) < 0`

 * `a must startWith(b)` is ok if `a startsWith b`
 * `a must notStartWith(b)` is ok if `!(a startsWith b)`

 * `a must endWith(b)` is ok if `a endsWith b`
 * `a must notEndWith(b)` is ok if `!(a endsWith b)`

===Detailed differences===

You can also get more detailed failure messages for String comparisons with the `detailedDiffs` method:
{{{
  object SpecificationWithDetailedFailures {
    detailedDiffs
    "abc" must_== "ab"    // 'ab(c)' is not equal to 'ab'
    "abcd" must_== "abd"  // 'ab(c)d' is not equal to 'abd'
    "acd" must_== "abd"   // 'a(c)d' is not equal to 'abd'

    // 'the kitt(en) is pret(ty)' is not equal to 'the (s)kitt(y) is pret(en)'
    "the kitten is pretty" must_== "the skitty is preten"   
  }
}}}

Note that you can change the pair of separators used to highlight the differences with:
{{{
  detailledDiffs("[]")
  // or detailledDiffs("<<>>") to separate with << and >>
}}}

=Matchers applicable to Iterables=
 
 * `a must contain(b)` is ok if `a.exists(_ == b)` (alias: `mustContain`)
 * `a must notContain(b)` is ok if `!a.exists(_ == b)` (alias: `mustNotContain`)

 * `a must exist(f)` is ok if a contains an element verifying the function f (alias: `mustExist`)
 * `a must notExist(f)` is ok if a doesn't contain an element verifying the function f (alias: `mustNotExist`)

 * `a must containMatch(b)` is ok if a contains a String matching the pattern `b` (alias: `existMatch`, `mustExistMatch`, `mustHaveMatch`)
 * `a must notContainMatch(b)` is ok if a doesn't contain a String matching the pattern `b` (alias: `notExistMatch`, `mustNotExistMatch`, `mustNotHaveMatch`)

 * `a must haveSameElementsAs(b)` is ok if a contains the same elements as the iterable b. This verification doesn't check the order of the elements but does a recursive verification is a and b contain iterables: 
{{{
List(1, List(2, 3, List(4)), 5) must haveSameElementsAs(List(5, List(List(4), 2, 3), 1))
}}}
 * `a must haveSize(3)` matches if there are 3 elements in a

=Matchers applicable to Maps=
 
 * `m must haveKey(k)` is ok if `map.exists(p => p._1 == k)`
 * `m must notHaveKey(k)` is ok if `!map.exists(p => p._1 == k)`

 * `m must haveValue(v)` is ok if `map.exists(p => p._2 == v)`
 * `m must notHaveValue(v)` is ok if `!map.exists(p => p._2 == v)`

 * `m must havePair(p)` is ok if `map.exists(p == _)`
 * `m must notHavePair(p)` is ok if `!map.exists(p == _)`

=Matchers applicable to numerical values=
 
 * `a must beGreaterThan(b)` is ok if `a >= b` (alias `be_>=`)
 * `a must beStrictlyGreaterThan(b)` is ok if `a > b` (alias `be_>`)

 * `a must beLessThan(b)` is ok if `a <= b` (alias `be_<=`)
 * `a must beStrictlyLessThan(b)` is ok if `a < b` (alias `be_<`)

 * `a must beCloseTo(b, delta)` is ok if `b - delta <= a <= b + delta`

=Matchers applicable to Options=
 
 * `a must beNone` is ok if a is None
 * `a must beAlsoNone(b)` is ok if a is None when b is None or a is not None when b is None
 * `a must beSome[Type]` is ok if a is Some(t: Type)
 * `a must beSomething` is ok if a is Some(a: Any)

 * an Option matcher can be extended with a `which` condition

{{{
  Some(x) must beSome[String].which(_.startWith("abc"))
}}}

=Matchers applicable to [http://code.google.com/p/scalacheck Scalacheck] properties=

Let's say you want to implement a function which returns all the prefixes of a given list:

{{{
prefixes(List(1, 2, 3)) // => List(List(1), List(1, 2), List(1, 2, 3))
}}}

You can use Scalacheck generators to generate lists of random size: 
{{{
  // list is an arbitrary list (with at least one element)
  // prefix is a random prefix of list
  // testData contains all the prefixes of list and a random prefix
  val testData = for (list <- listOf1(elements(1, 2, 3, 4));
                               n <- choose(1, list.size-1);
                               val prefix = list.take(n))
                            yield (prefixes(list), prefix)
}}}

Then, mixing the org.specs.Scalacheck trait to your specification, you can check that the prefix property passes all generated data:
{{{      
  // the generated data must pass the following property
  testData must pass { t: (List[List[Int]], Seq[Int]) => val (prefixes, prefix) = t
    prefixes must contain(prefix)
  }
}}}

 * You can also use a simple boolean function `prefixes.exist(_ == prefix)` instead of 
   the above matcher. The failure message will be however less precise

 * You can express things the other way around: 

`function must pass(generated_data)` instead of `generated_data must pass(function)`

 * You can simply use the `pass` matcher to verify a scalacheck property:

{{{
// this property will alway be true
val prop = property((a:Int) => true)
prop must pass
}}} 

 * You can display Scalacheck messages with `display` on the Console:

{{{
data must pass {
...
}(display)
}}} 

 * You can set Scalacheck properties with `set` (or `display` to additionally see the result on the Console):

{{{
data must pass {
...
}(set(minSize -> 10, maxSize -> 20, maxDiscarded -> 30, minTestsOk -> 5))
}}} 

where:

 * `minSize` is the minimum size for generated data (like lists)
 * `maxSize` is the maximum size for generated data (like lists)
 * `maxDiscarded` is the maximum number of tests which should be inconclusive in order for the property to pass
 * `minTestsOk` is the minimum number of tests which should be ok in order for the property to pass

 * the default is: `minTestsOk->100, maxDiscarded->500, minSize->0, maxSize->100`

===Assertions number===
*(from 1.3.2)*

By default, the statement `property must pass` will count each evaluation as one assertion. You can deactivate this behavior by declaring `dontAssertProperties` at the beginning of your specification and get finer control of what's counted as an assertion with `isAssertion`:

{{{
  dontAssertProperties()
  property((b: Boolean) => (b == true).isAssertion)
  // or
  property((b: Boolean) => isAssertion(b == true))
}}}

Of course, you can globally re-enable assertions counting with `assertProperties` for the rest of your specification:

{{{
  object spec extends Specification with Scalacheck {
    // no assertion count when evaluating properties
    dontAssertProperties()
    property((b: Boolean) => b == true)

    // one assertion will be counted on each property evaluation
    assertProperties()
    property((b: Boolean) => b == true)
  }
}}}

=Matchers applicable to XML=

 * `<a><b/></a> must equalIgnoreSpace(<a> <b/></a>)` is ok if the nodes are same but ignoring space (and inner nodes order). You can use `==/` as an alias

 * You can use the XPath-like `\` matcher to match nodes inside an xml node:
{{{ 
<a><b/></a> must \("b") // or <a><b/></a> must \(<b/>)
}}}

 * You can use the XPath-like `\\` matcher to match nodes deeply nested inside an xml node: `<a><s><c></c></s></a> must \\("c")`

 * `\` and `\\` can be composed to assert more complex statements: 
{{{
<a><b><c><d></d></c></b></a> must \\("c").\("d")
}}}

 * `\` and `\\` can also check for attribute names: 
{{{
<a><b name="value" name2="value"></b></a> must \("b", ("name2", "name")) // with the Sugar object implicitly transforming tuples to Lists 
}}}

 * `\` and `\\` can also check for inclusion of attribute names and values: 
{{{
<a><b name="value" name2="value2"></b></a> must \("b", Map("name"->"value")) // just checks the presence of "name" -> "value"
}}}

 * `\` and `\\` can also check for the presence of a whole Node: 
{{{
<a><b name="value"></b></a> must \(<b name="value"/>)
}}}

 * `==/` check if 2 nodes are equals, ignoring space (alias: `equalIgnoreSpace`)
{{{
<a>
  <b name="value">
  </b>
</a> must ==/(<a><b name="value"></b></a>)
}}}

=Matchers applicable to Paths and Files=

Most of the time, you should try to minimize the interactions with the File System. However, sometimes this is precisely what you want to specify! The following matchers will help you specify paths and files properties.

For paths (as strings):

 * `a must beEqualIgnoringSep(b)` matches if the path for a is the same than the path for b ignoring the system specific separators
 * `a must beAnExistingPath` matches if a is the path to an existing file or directory
 * `a must beAReadablePath` matches if a is the path can be read
 * `a must beAWritablePath` matches if a is the path can be written
 * `a must beAHiddenPath` matches if a is the path starts with "."
 * `a must beAnAbsolutePath` matches if a is absolute (starting with "/" under Unix/Linux)
 * `a must beACanonicalPath` matches if a is canonical (with no relative part like "../..")
 * `a must beAFilePath` matches if a points to a File
 * `a must beADirectoryPath` matches if a points to a Directory
 * `a must havePathName(name)` matches if a has "name" as a name
 * `a must haveAsAbsolutePath(path)` matches if a has "path" has path as a absolute path. For example, "./tmp" will have "c:/tmp" absolute path if the spec is executed under c:.
 * `a must haveAsCanonicalPath(path)` matches if a has "path" has path as a canonical path. For example, "c:/tmp/dir/.." has "c:/tmp" as a canonical path
 * `a must haveParentPath(path)` matches if a has "path" as a parent. For example, "c:/tmp/dir" has "c:/tmp" as a parent
 * `a must listPaths(path1, path2)` matches if a is a directory and has path1 and path2 as children

For files:

 * `file must exist` matches if file.exists
 * `file must beReadable` matches if file.canRead
 * `file must beWritable` matches if file.canWrite
 * `file must beAbsolute` matches if file.isAbsolute
 * `file must beHidden` matches if file.isHidden
 * `file must beFile` matches if file.isFile
 * `file must beDirectory` matches if file.isDirectory
 * `file must haveName(n)` matches if file.getName == n
 * `file must haveAbsolutePath(p)` matches if file.getAbsolutePath == p
 * `file must haveCanonicalPath(p)` matches if file.getCanonicalPath == p
 * `file must haveParent(p)` matches if file.getParent == p
 * `file must haveList(p1, p2)` matches if file.list == List(p1, p2)

Note: for the above matchers, when paths are compared, separators are always ignored.

=Matchers composition for object graphs=

You may want to combine several existing matchers to be able to match an entire object graph. For example, given the following class definitions:


{{{
trait ObjectGraph { 
  import scala.collection.mutable 

  case class Foo(val name:String) { 
    var singlebar: Bar = _ 
    val bars = mutable.Set[Bar]() 
  } 
  
  case class Bar(val id: Long)
}
}}}

You will define the following matchers for the classes Foo and Bar:
{{{
trait ObjectGraphMatchers extends ObjectGraph with Matchers {
  case class matchFoo(foo: Foo) extends Matcher[Foo] {
    def apply(other: => Foo) = {
      ((beEqual(_:String)) ^^^ ((f:Foo) => f.name) and
       (matchBar(_)) ^^^ ((f: Foo) => foo.singlebar) and
       (matchBar(_)).toSet ^^^ ((f: Foo) => foo.bars))(foo)(other)
    }
  }
  case class matchBar(bar: Bar) extends Matcher[Bar] {
    def apply(other: => Bar) = {
      ((beAlsoNull(_:Bar)) or 
      ((beEqual(_:Long)) ^^^ ((b: Bar) => b.id)))(bar)(other)
    }
  }
}
}}}

In the code above:

 * `matchBar(_)` is a function returning a matcher for Bar objects. It is composed (using the `^^^` operator) with a function extracting the `singlebar` from Foo objects in order to return a new matcher for Foo object which will also extract the `singlebar` field from the object to match (`other`). 

 * This could also be written using the `^^` operator as: `(((matchBar(_)) ^^ ((f:Foo) => f.singlebar))(foo) ^^ ((f:Foo) => f.singlebar))(other)`. In that expression, the first `^^` operator allows to select the `singlebar` field from foo to create a new Matcher of bar objects. And the second `^^` operator takes the resulting matcher and allow it to be applied to Foo objects which will have their `singlebar` field extracted

 * The `matchBar(_)` matcher is transformed to a matcher for sets of Bar objects using the toSet function. Similarly we could have applied a `toSeq` method to check for a Sequence of Bar objects

=Precise failures=
(*from 1.3.2*)

Most of the failure messages display an expected value and an actual value. But an actual value on what precisely?
{{{
  // will fail with "List(ticket1, ticket2) doesn't have size 3" for example
  machine.tickets must haveSize(3)
}}}

If you wish to get a more precise failure message on what's being tested you can set an alias with the "aka" method ("also known as"):

{{{
  // will fail with "the created tickets 'List(ticket1, ticket2)' doesn't have size 3"
  machine.tickets aka "the created tickets" must haveSize(3)
}}}


===xUnit assertions===

*specs* provides xUnit-like assertions to allow a smooth transition path from Test-Driven Development to Behavior-Driven Development:
{{{
object jUnitTest extends Specification {
  "provide the 'assertTrue' jUnit assertion" {
    assertTrue(1 == 1 + 1)
  }
}
}}}

 * `assertTrue`        <=> `must beTrue`
 * `assertFalse`       <=> `must beFalse`
 * `assertEquals`      <=> `must beEqual`
 * `assertSame`        <=> `mustBe`
 * `assertNotSame`     <=> `mustNotBe`
 * `assertNull`        <=> `must beNull`
 * `assertNotNull`     <=> `must notBeNull`
 * `assertArrayEquals` <=> `must ((beEqual(_:T)).toSeq`