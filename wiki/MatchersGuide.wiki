#summary How to add assertions to your examples

=Matchers presentation=

There are different kind of matchers which are used to assert that some properties must be verified. Generally they are used like this:

{{{
"This example presents a matcher" in {
  // verifyThisProperty is a Matcher
  myObject must verifyThisProperty(parameter)
}
}}}

===Create your own Matcher===

Creating a new Matcher is easy. You extend the `Matcher` class, using a case class and implement the `apply` method:

{{{
  "A matcher" can {
    "be created as a case class" in {
      case class matchHello(a: String) extends Matcher[String]() {
        def apply(v: => String) = (v == a, "okMessage", "koMessage")
      }
      "hello" must matchHello("hello")
    }
  }
}}} 

You must return a tuple containing:

 * a boolean value indicating a success or a failure when applied to the object which `must` match
 * a message which can be displayed in case of a success
 * a message which can be displayed in case of a failure

A matcher can also be created through as a val:

{{{
  "A matcher" can {
    "be created as a val" in {
      val beEven = new Matcher[Int] {
        def apply(b: => Int) = (b % 2 == 0, b + " is even", b + " is odd")
      }
      2 must beEven
    }
  }
}}}

Or through a method:
{{{
  "A matcher" can {
    "be created as a method" in {
      def divide(a: Int) = new Matcher[Int] {
        def apply(b: => Int) = (a % b == 0, b + " divides " + a, b + " doesn't divide " + a)
      }
      10 must divide(100)
      3 must not(divide(100))
    }
  }
}}}

===Create the negation of a matcher===

Simply use the `not` method on a matcher:

{{{
 2 must beEven
 val beOdd = beEven.not
 3 must beOdd
}}}

In that case, the ok message of the first matcher is used as a ko message for the second matcher.

===Combine matchers===

You can combine matchers with logical operators: `and`, `or`, `xor`, `verifyAll`, `verifyAny`

{{{
  "ab" must beMatching("a") and beMatching("b")
  "ab" must beMatching("a") or beMatching("c")
  "ab" must beMatching("a") xor beMatching("c")
  "ab" must verifyAll(beMatching("a"), beMatching("b"))
  "ab" must verifyAny(beMatching("a"), beMatching("b"))
}}}

`verifyAll` must be ok for all matchers and `verifyAny` must be ok for at least one matcher.

===Limit the applicability of a matcher===

In some cases, you may want to specify that a matcher is only applicable depending on some conditions:
{{{
 "abc" must beMatching(s).when(s == ".")
 "abc" must beMatching(s).unless(s.isEmpty)
}}}

=Matchers applicable to any object=

 * `a must be(b)` is ok if `a eq b` (alias: `a mustBe b` or `a mustEq b`)
 * `a must notBe(b)` is ok if `!(a eq b)` (alias: `a must notEq(b)` or `a mustNotBe(b)`)

 * `a must be_==(b)` is ok if `a == b` (alias: `a must_== b` or `a mustEqual b`)
 * `a must be_!=(b)` is ok if `a != b` (alias: `a must_!= b`)

 * `a must beEqual(b)` is ok if `a == b` and constrains a and b to have the same type at compilation time
 * `a must beDifferent(b)` is ok if `a != b` and constrains a and b to have the same type at compilation time

 * `a must beIn(iterable)` is ok if `iterable.exists(_ == a)`
 * `a must notBeIn(iterable)` is ok if `!iterable.exists(_ == a)`

 * `a must beEmpty` is ok if `a` defines a `isEmpty` method and `a.isEmpty`
 * `a must notBeEmpty` is ok if `a` defines a `isEmpty` method and `!a.isEmpty`

 * `a must verify(f)` is ok if `f(a) == true` (alias: `a mustVerify f` or `a verifies b`)

 * `a must beLike { case p => booleanFunction }` is ok if a matches the pattern `p` and the booleanFunction returns true:

{{{
List(1, 2) must beLike { case x::y::Nil => true }
}}}

===If you want to verify that an exception is thrown===

 * `a must throwA(new Exception)` is ok if evaluating `a` throws a Exception (alias: `throwAn`)
 * `a must throwA(new Exception)like {case Exception(m) => m.startsWith("bad")} ` is ok if evaluating `a` throws an Exception and the message starts with "bad"

 * `a must throwThis(new Exception("message"))` is ok if evaluating `a` throws an exception e and `e == new Exception("message")`
 
=Matchers applicable to Strings=
 
 * `a must equalIgnoreCase(b)` is ok if `a equalsIgnoreCase(b)` (alias: `a must_==/ b`)
 * `a must notEqualIgnoreCase(b)` is ok if `!(a equalsIgnoreCase(b))` (alias: `a must_!=/ b`)

 * `a must beMatching(b)` is ok if a matches the regexp b (alias: `a mustMatch b`)
 * `a must notBeMatching(b)` is ok if a doesn't match the regexp b (alias: `a mustNotMatch b`)

 * `a must include(b)` is ok if `a.indexOf(b) >= 0`
 * `a must notInclude(b)` is ok if `a.indexOf(b) < 0`

 * `a must startWith(b)` is ok if `a startsWith b`
 * `a must notStartWith(b)` is ok if `!(a startsWith b)`

 * `a must endWith(b)` is ok if `a endsWith b`
 * `a must notEndWith(b)` is ok if `!(a endsWith b)`

=Matchers applicable to Iterables=
 
 * `a must contain(b)` is ok if `a.exists(_ == b)` (alias: `mustContain`)
 * `a must notContain(b)` is ok if `!a.exists(_ == b)` (alias: `mustNotContain`)

 * `a must exist(f)` is ok if a contains an element verifying the function f (alias: `mustExist`)
 * `a must notExist(f)` is ok if a doesn't contain an element verifying the function f (alias: `mustNotExist`)

 * `a must containMatch(b)` is ok if a contains a String matching the pattern `b` (alias: `existMatch`, `mustExistMatch`, `mustHaveMatch`)
 * `a must notContainMatch(b)` is ok if a doesn't contain a String matching the pattern `b` (alias: `notExistMatch`, `mustNotExistMatch`, `mustNotHaveMatch`)

 * `a must haveTheSameElementsAs(b)` is ok if a contains the same elements as the iterable b. This verification doesn't check the order of the elements but does a recursive verification is a and b contain iterables: 
{{{
List(1, List(2, 3, List(4)), 5) must haveTheSameElementsAs(List(5, List(List(4), 2, 3), 1))
}}}

=Matchers applicable to Maps=
 
 * `m must haveKey(k)` is ok if `map.exists(p => p._1 == k)`
 * `m must notHaveKey(k)` is ok if `!map.exists(p => p._1 == k)`

 * `m must haveValue(v)` is ok if `map.exists(p => p._2 == v)`
 * `m must notHaveValue(v)` is ok if `!map.exists(p => p._2 == v)`

 * `m must havePair(p)` is ok if `map.exists(p == _)`
 * `m must notHavePair(p)` is ok if `!map.exists(p == _)`

=Matchers applicable to numerical values=
 
 * `a must beGreaterThan(b)` is ok if `a >= b`
 * `a must beStrictlyGreaterThan(b)` is ok if `a > b`

 * `a must beLessThan(b)` is ok if `a <= b`
 * `a must beStrictlyLessThan(b)` is ok if `a < b`

 * `a must beCloseTo(b, delta)` is ok if `b - delta <= a <= b + delta`

=Matchers applicable to Options=
 
 * `a must beNone` is ok if a is None
 * `a must beSome[Type]` is ok if a is Some(t: Type)
 * `a must beSomething` is ok if a is Some(a: Any)

 * an Option matcher can be extended with a `which` condition

{{{
  Some(x) must beSome[String].which(_.startWith("abc"))
}}}

=Matchers applicable to [http://code.google.com/p/scalacheck Scalacheck] properties=

Let's say you want to implement a function which returns all the prefixes of a given list:

{{{
prefixes(List(1, 2, 3)) // => List(List(1), List(1, 2), List(1, 2, 3))
}}}

You can use Scalacheck generators to generate lists of random size: 
{{{
  // list is an arbitrary list (with at least one element)
  // prefix is a random prefix of list
  // testData contains all the prefixes of list and a random prefix
  val testData = for (list <- listOf1(elements(1, 2, 3, 4));
                               n <- choose(1, list.size-1);
                               val prefix = list.take(n))
                            yield (prefixes(list), prefix)
      
  // the generated data must pass the following property
  testData must pass { t: (List[List[Int]], Seq[Int]) => val (prefixes, prefix) = t
    prefixes must contain(prefix)
  }
}}}

 * You can also use a simple boolean function `prefixes.exist(_ == prefix)` instead of 
   the above matcher. The failure message will be however less precise

 * You can express things the other way around: 

`function must pass(generated_data)` instead of `generated_data must pass(function)`

 * You can simply use the `pass` matcher to verify a scalacheck property:

{{{
// this property will alway be true
val prop = property((a:Int) => true)
prop must pass
}}} 

 * You can display Scalacheck messages with `display` on the Console (import `org.specs.matcher.ScalacheckParameters._`):

{{{
data must pass {
...
}(display)
}}} 

 * You can set Scalacheck properties with `set` (or `display` to additionally see the result on the Console):

{{{
data must pass {
...
}(set(minSize -> 10, maxSize -> 20, maxDiscarded -> 30, minTestsOk -> 5))
}}} 

where:

 * `minSize` is the minimum size for generated data (like lists)
 * `maxSize` is the maximum size for generated data (like lists)
 * `maxDiscarded` is the maximum number of tests which should be inconclusive in order for the property to pass
 * `minTestsOk` is the minimum number of tests which should be ok in order for the property to pass

 * the default is: `minTestsOk->100, maxDiscarded->500, minSize->0, maxSize->100`

=Matchers applicable to XML=

 * `<a><b/></a> must equalIgnoreSpace(<a> <b/></a>)` is ok if the nodes are same but ignoring space (and inner nodes order). You can use `==/` as an alias

 * You can use the XPath-like `\` matcher to match nodes inside an xml node:
{{{ 
<a><b/></a> must \("b") // or <a><b/></a> must \(<b/>)
}}}

 * You can use the XPath-like `\\` matcher to match nodes deeply nested inside an xml node: `<a><s><c></c></s></a> must \\("c")`

 * `\` and `\\` can be composed to assert more complex statements: 
{{{
<a><b><c><d></d></c></b></a> must \\("c").\("d")
}}}

 * `\` and `\\` can also check for attribute names: 
{{{
<a><b name="value" name2="value"></b></a> must \("b", ("name2", "name")) // with the Sugar object implicitly transforming tuples to Lists 
}}}

 * `\` and `\\` can also check for inclusion of attribute names and values: 
{{{
<a><b name="value" name2="value2"></b></a> must \("b", Map("name"->"value")) // just checks the presence of "name" -> "value"
}}}

 * `\` and `\\` can also check for the presence of a whole Node: 
{{{
<a><b name="value"></b></a> must \(<b name="value"/>)
}}}